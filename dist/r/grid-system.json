{
  "name": "grid-system",
  "type": "registry:ui",
  "title": "Grid System",
  "description": "Complete polymorphic grid layout system with resizable panels",
  "files": [
    {
      "path": "components/grid/grid.tsx",
      "type": "registry:component",
      "content": "import { forwardRef, useRef, useImperativeHandle, useMemo } from \"react\";\nimport type { GridProps, BlockConfig, GridState } from \"@/lib/grid-types\";\nimport { cn } from \"@/lib/utils\";\nimport { GridProvider, useGridContext } from \"@/components/grid/grid-provider\";\nimport { useGridResize } from \"@/hooks/use-grid-resize\";\nimport { useGridKeyboard } from \"@/hooks/use-grid-keyboard\";\nimport { generateGridTemplate } from \"@/lib/grid-calculations\";\nimport { DividerOverlay } from \"@/components/divider/divider-overlay\";\n\n/**\n * Grid API for imperative control\n */\nexport interface GridAPI {\n  resizeBlock: (blockId: string, size: number) => void;\n  collapseBlock: (blockId: string) => void;\n  expandBlock: (blockId: string) => void;\n  switchMode: (mode: string) => void;\n  persistState: () => void;\n  resetState: () => void;\n  getState: () => GridState;\n}\n\n/**\n * Internal Grid component (wrapped by provider)\n */\nconst GridInternal = forwardRef<\n  GridAPI,\n  Omit<\n    GridProps,\n    | \"defaultLayout\"\n    | \"modes\"\n    | \"persist\"\n    | \"persistKey\"\n    | \"onLayoutChange\"\n    | \"onModeChange\"\n  >\n>(({ children, className, \"aria-label\": ariaLabel }, ref) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const {\n    state,\n    resizeBlock,\n    collapseBlock,\n    expandBlock,\n    switchMode,\n    persistState,\n    resetState,\n  } = useGridContext();\n\n  // Get resize state\n  const isDragging = state.resize.isDragging;\n\n  // Expose API through ref\n  useImperativeHandle(\n    ref,\n    () => ({\n      resizeBlock,\n      collapseBlock,\n      expandBlock,\n      switchMode,\n      persistState,\n      resetState,\n      getState: () => state,\n    }),\n    [\n      resizeBlock,\n      collapseBlock,\n      expandBlock,\n      switchMode,\n      persistState,\n      resetState,\n      state,\n    ]\n  );\n\n  // Get blocks as array sorted by order\n  const blocks = useMemo(() => {\n    const blockArray = Object.values(state.blocks);\n    return blockArray.sort((a, b) => (a.order || 0) - (b.order || 0));\n  }, [state.blocks]);\n\n  // Get root block (parent_id is null)\n  const rootBlock = useMemo(() => {\n    return blocks.find((block) => !block.parentId);\n  }, [blocks]);\n\n  // Legacy resize support (keeping for backward compatibility)\n  useGridResize({\n    blocks,\n    containerRef,\n    onSizeChange: resizeBlock,\n    direction: rootBlock?.direction || \"row\",\n  });\n\n  // Set up keyboard navigation\n  useGridKeyboard({\n    enabled: true,\n    blocks,\n    containerRef,\n    onResizeBlock: (blockId, delta) => {\n      const block = state.blocks[blockId];\n      if (block) {\n        const currentSize = block.defaultSize || 0;\n        const newSize = Math.max(0, currentSize + delta);\n        resizeBlock(blockId, newSize);\n      }\n    },\n    onCollapseBlock: collapseBlock,\n    onExpandBlock: expandBlock,\n  });\n\n  // Note: Dividers are now handled by DividerOverlay as absolutely positioned overlays\n\n  // Generate CSS styles for the grid\n  const { gridStyles, cssVariables, modeStyles } = useMemo(() => {\n    if (!rootBlock) {\n      return { gridStyles: \"\", cssVariables: \"\", modeStyles: \"\" };\n    }\n\n    // Get blocks grouped by parent\n    const blocksByParent = blocks.reduce((acc, block) => {\n      // Skip the root block itself when grouping by parent\n      if (block.id === rootBlock.id) return acc;\n\n      const parentId = block.parentId || rootBlock.id;\n      if (!acc[parentId]) acc[parentId] = [];\n      acc[parentId].push(block);\n      return acc;\n    }, {} as Record<string, BlockConfig[]>);\n\n    // Generate CSS variables for block sizes (scoped by grid ID to prevent collisions)\n    const variables = blocks\n      .filter((block) => block.defaultSize !== undefined)\n      .map((block) => {\n        const sizeValue =\n          block.sizeUnit === \"px\"\n            ? `${block.defaultSize}px`\n            : `${block.defaultSize}fr`;\n        return `--${rootBlock.id}-${block.id}-size: ${sizeValue};`;\n      })\n      .join(\"\\n  \");\n\n    // Mode-specific styles removed - will be re-added when modes are properly designed\n    const generateModeStyles = (): string => {\n      return \"\";\n    };\n\n    // Generate dynamic grid styles based on block tree structure\n    const generateGroupStyles = (\n      parentId: string,\n      visited: Set<string> = new Set()\n    ): string => {\n      // Prevent infinite recursion\n      if (visited.has(parentId)) {\n        console.warn(`Circular reference detected for parent: ${parentId}`);\n        return \"\";\n      }\n\n      // Create a new set for this branch to avoid cross-contamination\n      const newVisited = new Set(visited);\n      newVisited.add(parentId);\n\n      const childBlocks = blocksByParent[parentId] || [];\n      if (childBlocks.length === 0) return \"\";\n\n      // Sort by order\n      const sortedBlocks = [...childBlocks].sort(\n        (a, b) => (a.order || 0) - (b.order || 0)\n      );\n\n      // Generate grid template for this group\n      const parentBlock = blocks.find((b) => b.id === parentId) || rootBlock;\n      const direction = parentBlock?.direction || \"row\";\n\n      // Generate grid template from blocks (dividers are overlays, not part of the grid)\n      const blocksForTemplate = sortedBlocks.map((block) => ({\n        id: block.id,\n        sizeUnit: block.sizeUnit || \"fr\",\n        size: block.defaultSize || 1,\n        dividerPosition: \"none\" as const, // Dividers are overlays, not in grid template\n        dividerSize: 0, // Not used since dividers are overlays\n      }));\n\n      const template = generateGridTemplate(blocksForTemplate, rootBlock.id);\n\n      const templateProperty =\n        direction === \"column\" ? \"grid-template-rows\" : \"grid-template-columns\";\n\n      // Simple selector - just target the block group by ID and type\n      // Grid-scoped to prevent collisions across multiple grids\n      const selector = `[data-block-id=\"${parentId}\"]`;\n\n      let groupStyle = `\n${selector} {\n  display: grid;\n  ${templateProperty}: ${template};\n  ${\n    direction === \"column\"\n      ? \"grid-template-columns: 1fr;\"\n      : \"grid-template-rows: 1fr;\"\n  }\n}`;\n\n      // Generate styles for child groups recursively\n      for (const childBlock of sortedBlocks) {\n        if (childBlock.type === \"group\") {\n          groupStyle += generateGroupStyles(childBlock.id, newVisited);\n        }\n      }\n\n      return groupStyle;\n    };\n\n    const dynamicStyles = generateGroupStyles(rootBlock.id);\n    const modeDynamicStyles = generateModeStyles();\n\n    return {\n      cssVariables: `:root {\\n  ${variables}\\n}`,\n      gridStyles: dynamicStyles,\n      modeStyles: modeDynamicStyles,\n    };\n  }, [blocks, rootBlock]);\n\n  if (!rootBlock) {\n    console.warn(\"No root block found in grid configuration\");\n    return null;\n  }\n\n  return (\n    <>\n      {/* Inject styles */}\n      <style type=\"text/css\">\n        {cssVariables}\n        {gridStyles}\n        {modeStyles}\n      </style>\n\n      <div\n        ref={containerRef}\n        className={cn(\n          \"group relative overflow-hidden\",\n          isDragging &&\n            \"select-none cursor-grabbing pretty-poly-grid--dragging\",\n          className\n        )}\n        data-grid-id={rootBlock.id}\n        data-block-id={rootBlock.id}\n        data-block-type={rootBlock.type}\n        data-active-mode={state.activeMode}\n        aria-label={ariaLabel || \"Resizable grid layout\"}\n        role=\"application\"\n        style={{ isolation: \"isolate\" }}\n      >\n        {children}\n\n        {/* Divider overlay - only in grid/desktop mode */}\n        {(state.activeMode === \"grid\" || state.activeMode === \"desktop\") && (\n          <DividerOverlay />\n        )}\n      </div>\n    </>\n  );\n});\n\nGridInternal.displayName = \"GridInternal\";\n\n/**\n * Main Grid component with provider wrapper\n */\nexport const Grid = forwardRef<GridAPI, GridProps>(\n  (\n    {\n      children,\n      defaultLayout = [],\n      modes,\n      persist = false,\n      persistKey,\n      onLayoutChange,\n      onModeChange,\n      className,\n      dividers = \"manual\",\n      dividerConfig,\n      \"aria-label\": ariaLabel,\n    },\n    ref\n  ) => {\n    // Find root block ID for gridId\n    const rootBlock = defaultLayout.find((block) => !block.parentId);\n    const gridId = rootBlock?.id || \"root\";\n\n    return (\n      <GridProvider\n        blocks={defaultLayout}\n        modes={modes}\n        gridId={gridId}\n        persist={persist}\n        persistKey={persistKey}\n        onLayoutChange={onLayoutChange}\n        onModeChange={onModeChange}\n      >\n        <GridInternal\n          ref={ref}\n          className={className}\n          dividers={dividers}\n          dividerConfig={dividerConfig}\n          aria-label={ariaLabel}\n        >\n          {children}\n        </GridInternal>\n      </GridProvider>\n    );\n  }\n);\n\nGrid.displayName = \"Grid\";\n",
      "target": "components/grid/grid.tsx"
    },
    {
      "path": "components/grid/grid-provider.tsx",
      "type": "registry:component",
      "content": "import React, {\n  createContext,\n  useContext,\n  useReducer,\n  useEffect,\n  useMemo,\n} from \"react\";\nimport type {\n  GridState,\n  GridAction,\n  GridContextValue,\n  BlockConfig,\n  ResponsiveModes,\n  ViewportInfo,\n} from \"@/lib/grid-types\";\nimport { useGridMode } from \"@/hooks/use-grid-mode\";\nimport { useGridPersistence } from \"@/hooks/use-grid-persistence\";\nimport { useGridResizeOperations } from \"@/hooks/use-grid-resize-operations\";\n\n/**\n * Grid state reducer\n */\nfunction gridStateReducer(state: GridState, action: GridAction): GridState {\n  switch (action.type) {\n    case \"RESIZE_BLOCK\":\n      const block = state.blocks[action.payload.blockId];\n      if (!block) return state;\n\n      return {\n        ...state,\n        blocks: {\n          ...state.blocks,\n          [action.payload.blockId]: {\n            ...block,\n            defaultSize: action.payload.size,\n            size: action.payload.size,\n          },\n        },\n      };\n\n    case \"COLLAPSE_BLOCK\":\n      const collapseBlock = state.blocks[action.payload.blockId];\n      if (!collapseBlock) return state;\n\n      const collapseSize = collapseBlock.collapseTo || 0;\n      return {\n        ...state,\n        blocks: {\n          ...state.blocks,\n          [action.payload.blockId]: {\n            ...collapseBlock,\n            // Preserve original size for expand\n            originalDefaultSize:\n              collapseBlock.originalDefaultSize || collapseBlock.defaultSize,\n            defaultSize: collapseSize,\n            size: collapseSize,\n          },\n        },\n      };\n\n    case \"EXPAND_BLOCK\":\n      const expandBlock = state.blocks[action.payload.blockId];\n      if (!expandBlock) return state;\n\n      // Restore to the original default size defined in configuration\n      const originalSize =\n        expandBlock.originalDefaultSize || expandBlock.defaultSize || 100;\n      return {\n        ...state,\n        blocks: {\n          ...state.blocks,\n          [action.payload.blockId]: {\n            ...expandBlock,\n            defaultSize: originalSize,\n            size: originalSize,\n          },\n        },\n      };\n\n    case \"SET_ACTIVE_DIVIDER\":\n      return {\n        ...state,\n        activeDivider: action.payload.dividerId,\n      };\n\n    case \"SWITCH_MODE\":\n      return {\n        ...state,\n        activeMode: action.payload.mode,\n      };\n\n    case \"UPDATE_VIEWPORT\":\n      return {\n        ...state,\n        viewport: action.payload.viewport,\n      };\n\n    case \"LOAD_STATE\":\n      return {\n        ...state,\n        ...action.payload.state,\n        // Always preserve current viewport\n        viewport: state.viewport,\n      };\n\n    case \"RESET_STATE\":\n      // Reset block sizes to their original defaults\n      const resetBlocks = Object.fromEntries(\n        Object.entries(state.blocks).map(([id, block]) => [\n          id,\n          {\n            ...block,\n            size: block.defaultSize,\n            // Reset to original defaultSize stored somewhere, or current defaultSize\n          },\n        ])\n      );\n      return {\n        ...state,\n        blocks: resetBlocks,\n        activeDivider: undefined,\n        resize: {\n          isDragging: false,\n          startPosition: { x: 0, y: 0 },\n          initialSize: 0,\n        },\n      };\n\n    case \"START_RESIZE\":\n      return {\n        ...state,\n        resize: {\n          isDragging: true,\n          activeBlockId: action.payload.blockId,\n          activeDividerId: action.payload.dividerId,\n          startPosition: action.payload.startPosition,\n          initialSize: action.payload.initialSize,\n          initialAdjacentBlockId: action.payload.initialAdjacentBlockId,\n          initialAdjacentSize: action.payload.initialAdjacentSize,\n        },\n      };\n\n    case \"UPDATE_RESIZE\":\n      return {\n        ...state,\n        resize: {\n          ...state.resize,\n          // The resize calculation happens in the resize handler, not the reducer\n        },\n      };\n\n    case \"END_RESIZE\":\n      return {\n        ...state,\n        resize: {\n          isDragging: false,\n          startPosition: { x: 0, y: 0 },\n          initialSize: 0,\n        },\n      };\n\n    default:\n      return state;\n  }\n}\n\n/**\n * Create initial grid state from block configurations\n */\nfunction createInitialState(\n  blocks: BlockConfig[],\n  viewport: ViewportInfo,\n  activeMode: string\n): GridState {\n  const blocksMap = blocks.reduce((acc, block) => {\n    acc[block.id] = {\n      ...block,\n      size: block.defaultSize,\n      originalDefaultSize: block.defaultSize, // Store original size for expand functionality\n    };\n    return acc;\n  }, {} as Record<string, BlockConfig>);\n\n  return {\n    blocks: blocksMap,\n    activeMode,\n    viewport,\n    resize: {\n      isDragging: false,\n      startPosition: { x: 0, y: 0 },\n      initialSize: 0,\n    },\n  };\n}\n\n// Context\nconst GridContext = createContext<GridContextValue | null>(null);\n\nexport interface GridProviderProps {\n  children: React.ReactNode;\n  blocks: BlockConfig[];\n  modes?: ResponsiveModes;\n  gridId?: string;\n  persist?:\n    | boolean\n    | \"localStorage\"\n    | \"sessionStorage\"\n    | ((state: GridState) => void);\n  persistKey?: string;\n  onModeChange?: (newMode: string, previousMode: string) => void;\n  onLayoutChange?: (blocks: BlockConfig[]) => void;\n}\n\n/**\n * Grid context provider component\n */\nexport function GridProvider({\n  children,\n  blocks,\n  modes,\n  gridId = \"default\",\n  persist = false,\n  persistKey,\n  onModeChange,\n  onLayoutChange,\n}: GridProviderProps) {\n  // Mode management\n  const { activeMode, viewport, setMode: setModeInternal } = useGridMode(modes);\n\n  // Initialize state\n  const [state, dispatch] = useReducer(\n    gridStateReducer,\n    createInitialState(blocks, viewport, activeMode)\n  );\n\n  // Update viewport in state when it changes\n  useEffect(() => {\n    dispatch({\n      type: \"UPDATE_VIEWPORT\",\n      payload: { viewport },\n    });\n  }, [viewport]);\n\n  // Update active mode in state when it changes\n  useEffect(() => {\n    const previousMode = state.activeMode;\n    if (activeMode !== previousMode) {\n      dispatch({\n        type: \"SWITCH_MODE\",\n        payload: { mode: activeMode },\n      });\n      onModeChange?.(activeMode, previousMode);\n    }\n  }, [activeMode, state.activeMode, onModeChange]);\n\n  // Persistence\n  const { saveState, clearState } = useGridPersistence({\n    gridId: persistKey || gridId,\n    enabled: persist,\n    state,\n    onStateLoad: (loadedState) => {\n      dispatch({ type: \"LOAD_STATE\", payload: { state: loadedState } });\n    },\n    autoSave: true,\n  });\n\n  // Resize operations (extracted to custom hook)\n  const { startResize, updateResize, endResize } = useGridResizeOperations(state, dispatch);\n\n  // Create context value\n  const contextValue: GridContextValue = useMemo(\n    () => ({\n      gridId,\n      state: {\n        ...state,\n        activeMode,\n        viewport,\n      },\n      dispatch,\n\n      // Grid operations\n      resizeBlock: (blockId: string, size: number) => {\n        dispatch({\n          type: \"RESIZE_BLOCK\",\n          payload: { blockId, size },\n        });\n      },\n\n      collapseBlock: (blockId: string) => {\n        dispatch({\n          type: \"COLLAPSE_BLOCK\",\n          payload: { blockId },\n        });\n      },\n\n      expandBlock: (blockId: string) => {\n        dispatch({\n          type: \"EXPAND_BLOCK\",\n          payload: { blockId },\n        });\n      },\n\n      switchMode: (mode: string) => {\n        setModeInternal(mode);\n      },\n\n      // Resize operations (using extracted hook)\n      startResize,\n      updateResize,\n      endResize,\n\n      // Persistence\n      persistState: () => saveState(state),\n      resetState: () => {\n        dispatch({ type: \"RESET_STATE\" });\n        clearState();\n      },\n    }),\n    [gridId, state, activeMode, viewport, saveState, clearState, setModeInternal, startResize, updateResize, endResize]\n  );\n\n  // Notify parent of layout changes\n  useEffect(() => {\n    if (onLayoutChange) {\n      const blockConfigs = Object.values(state.blocks);\n      onLayoutChange(blockConfigs);\n    }\n  }, [state.blocks, onLayoutChange]);\n\n  return (\n    <GridContext.Provider value={contextValue}>{children}</GridContext.Provider>\n  );\n}\n\n/**\n * Hook to access grid context\n */\n// eslint-disable-next-line react-refresh/only-export-components\nexport function useGridContext(): GridContextValue {\n  const context = useContext(GridContext);\n  if (!context) {\n    throw new Error(\"useGridContext must be used within a GridProvider\");\n  }\n  return context;\n}\n\n/**\n * Hook to access grid state\n */\n// eslint-disable-next-line react-refresh/only-export-components\nexport function useGridState() {\n  const { state } = useGridContext();\n  return state;\n}\n\n/**\n * Hook to access grid actions\n */\n// eslint-disable-next-line react-refresh/only-export-components\nexport function useGridActions() {\n  const {\n    resizeBlock,\n    collapseBlock,\n    expandBlock,\n    switchMode,\n    persistState,\n    resetState,\n  } = useGridContext();\n  return {\n    resizeBlock,\n    collapseBlock,\n    expandBlock,\n    switchMode,\n    persistState,\n    resetState,\n  };\n}\n\n/**\n * Hook to access resize operations\n */\n// eslint-disable-next-line react-refresh/only-export-components\nexport function useGridResize() {\n  const { startResize, updateResize, endResize, state } = useGridContext();\n  return {\n    startResize,\n    updateResize,\n    endResize,\n    isDragging: state.resize.isDragging,\n    activeBlockId: state.resize.activeBlockId,\n    activeDividerId: state.resize.activeDividerId,\n  };\n}\n",
      "target": "components/grid/grid-provider.tsx"
    },
    {
      "path": "components/grid/block.tsx",
      "type": "registry:component",
      "content": "import { forwardRef, useMemo } from 'react'\nimport type { BlockProps } from \"@/lib/grid-types\"\nimport { cn } from \"@/lib/utils\"\nimport { useGridContext, useGridState, useGridActions } from \"@/components/grid/grid-provider\"\nimport { useGridMode } from \"@/hooks/use-grid-mode\"\nimport { BlockContent } from \"@/components/grid/block-content\"\nimport { BlockHeader } from \"@/components/grid/block-header\"\nimport { BlockFooter } from \"@/components/grid/block-footer\"\nimport { BlockToolbar } from \"@/components/grid/block-toolbar\"\nimport { BlockTabs } from \"@/components/grid/block-tabs\"\nimport { BlockSidebar } from \"@/components/grid/block-sidebar\"\nimport { BlockSidebarItem } from \"@/components/grid/block-sidebar-item\"\nimport { BlockSidebarSpacer } from \"@/components/grid/block-sidebar-spacer\"\nimport { BlockLayout } from \"@/components/grid/block-layout\"\n\n/**\n * Block component for grid layouts\n */\nexport const Block = forwardRef<HTMLDivElement, BlockProps>(\n  ({\n    id,\n    type = 'block',\n    direction = 'row',\n    children,\n    className,\n    divider,\n    noDivider,\n    'aria-label': ariaLabel\n  }, ref) => {\n    const { gridId } = useGridContext()\n    const state = useGridState()\n    const { collapseBlock, expandBlock } = useGridActions()\n    const { supportsFeature } = useGridMode()\n\n    // Get block configuration from state\n    const blockConfig = state?.blocks[id]\n\n    // Calculate collapsed state\n    const isCollapsed = useMemo(() => {\n      if (blockConfig?.collapsible && blockConfig.collapseAt) {\n        const currentSize = blockConfig.size ?? blockConfig.defaultSize ?? 0\n        return currentSize <= blockConfig.collapseAt\n      }\n      return false\n    }, [blockConfig])\n\n    // Handle double-click for collapse/expand\n    const handleDoubleClick = () => {\n      if (blockConfig?.collapsible && blockConfig.collapseAt) {\n        const currentSize = blockConfig.size ?? blockConfig.defaultSize ?? 0\n        const isCollapsed = currentSize <= blockConfig.collapseAt\n        if (isCollapsed) {\n          expandBlock(id)\n        } else {\n          collapseBlock(id)\n        }\n      }\n    }\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          // Base styles - simple grid item that fills its space\n          'relative',\n          'w-full h-full',\n          'overflow-hidden',\n          'transition-opacity duration-150',\n          isCollapsed && 'opacity-70',\n          className\n        )}\n        data-grid-id={gridId}\n        data-block-id={id}\n        data-block-type={type}\n        data-block-direction={direction}\n        data-block-size-default={blockConfig?.defaultSize}\n        data-block-size-unit={blockConfig?.sizeUnit}\n        data-block-size-min={blockConfig?.minSize}\n        data-block-size-max={blockConfig?.maxSize}\n        data-block-collapse-at={blockConfig?.collapseAt}\n        data-block-collapse-to={blockConfig?.collapseTo}\n        data-block-divider-position={blockConfig?.dividerPosition}\n        data-block-divider-size={blockConfig?.dividerSize}\n        data-block-divider={divider !== undefined ? JSON.stringify(divider) : undefined}\n        data-block-no-divider={noDivider}\n        aria-label={ariaLabel}\n        role={type === 'group' ? 'group' : undefined}\n        tabIndex={supportsFeature('resizing') ? 0 : undefined}\n        onDoubleClick={supportsFeature('collapse') ? handleDoubleClick : undefined}\n      >\n        {children}\n      </div>\n    )\n  }\n)\n\nBlock.displayName = 'Block'\n\n/**\n * Block.Group component for nested layouts\n */\nexport const BlockGroup = forwardRef<HTMLDivElement, BlockProps>(\n  (props, ref) => {\n    return <Block ref={ref} {...props} type=\"group\" />\n  }\n)\n\nBlockGroup.displayName = 'Block.Group'\n\n// Add all sub-components as properties of Block\nObject.assign(Block, {\n  Group: BlockGroup,\n  Layout: BlockLayout,\n  Header: BlockHeader,\n  Content: BlockContent,\n  Footer: BlockFooter,\n  Toolbar: BlockToolbar,\n  Tabs: BlockTabs,\n  Sidebar: BlockSidebar\n})\n\n// Add nested sidebar components\nObject.assign(BlockSidebar, {\n  Item: BlockSidebarItem,\n  Spacer: BlockSidebarSpacer\n})",
      "target": "components/grid/block.tsx"
    },
    {
      "path": "components/grid/block-content.tsx",
      "type": "registry:component",
      "content": "import { forwardRef } from 'react'\nimport { cn } from \"@/lib/utils\"\n\nexport type ScrollMode = 'vertical' | 'horizontal' | 'both' | 'none'\n\nexport interface BlockContentProps {\n  scrollMode?: ScrollMode\n  className?: string\n  children: React.ReactNode\n  'aria-label'?: string\n}\n\n/**\n * BlockContent component for main scrollable content areas\n * Handles different scrolling behaviors and fills remaining space in block\n */\nexport const BlockContent = forwardRef<HTMLDivElement, BlockContentProps>(\n  ({ scrollMode = 'vertical', className, children, 'aria-label': ariaLabel }, ref) => {\n    const scrollClasses = {\n      vertical: 'overflow-y-auto overflow-x-hidden',\n      horizontal: 'overflow-x-auto overflow-y-hidden',\n      both: 'overflow-auto',\n      none: 'overflow-hidden'\n    }\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          'pretty-poly-block-content',\n          'flex-1', // Fill remaining space\n          'min-h-0', // Allow flex shrinking\n          scrollClasses[scrollMode],\n          className\n        )}\n        data-scroll-mode={scrollMode}\n        aria-label={ariaLabel}\n        role=\"main\"\n      >\n        {children}\n      </div>\n    )\n  }\n)\n\nBlockContent.displayName = 'Block.Content'",
      "target": "components/grid/block-content.tsx"
    },
    {
      "path": "components/grid/block-header.tsx",
      "type": "registry:component",
      "content": "import { forwardRef } from 'react'\nimport { cn } from \"@/lib/utils\"\n\nexport type HeaderPosition = 'top' | 'bottom'\n\nexport interface BlockHeaderProps {\n  position?: HeaderPosition\n  className?: string\n  children: React.ReactNode\n  'aria-label'?: string\n}\n\n/**\n * BlockHeader component for fixed header/toolbar areas\n * Does not scroll with content, stays in fixed position\n */\nexport const BlockHeader = forwardRef<HTMLDivElement, BlockHeaderProps>(\n  ({ position = 'top', className, children, 'aria-label': ariaLabel }, ref) => {\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          'pretty-poly-block-header',\n          'flex-shrink-0', // Don't shrink\n          'flex flex-row items-center', // Default to horizontal layout\n          'min-h-0', // Allow content to determine height\n          position === 'bottom' && 'order-last', // Move to bottom if specified\n          className\n        )}\n        data-header-position={position}\n        aria-label={ariaLabel}\n        role=\"banner\"\n      >\n        {children}\n      </div>\n    )\n  }\n)\n\nBlockHeader.displayName = 'Block.Header'",
      "target": "components/grid/block-header.tsx"
    },
    {
      "path": "components/grid/block-footer.tsx",
      "type": "registry:component",
      "content": "import { forwardRef } from 'react'\nimport { cn } from \"@/lib/utils\"\n\nexport interface BlockFooterProps {\n  className?: string\n  children: React.ReactNode\n  'aria-label'?: string\n}\n\n/**\n * BlockFooter component for fixed footer/status bar areas\n * Does not scroll with content, stays at bottom of block\n */\nexport const BlockFooter = forwardRef<HTMLDivElement, BlockFooterProps>(\n  ({ className, children, 'aria-label': ariaLabel }, ref) => {\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          'pretty-poly-block-footer',\n          'flex-shrink-0', // Don't shrink\n          'flex flex-row items-center', // Default to horizontal layout\n          'min-h-0', // Allow content to determine height\n          'order-last', // Always at bottom\n          className\n        )}\n        aria-label={ariaLabel}\n        role=\"contentinfo\"\n      >\n        {children}\n      </div>\n    )\n  }\n)\n\nBlockFooter.displayName = 'Block.Footer'",
      "target": "components/grid/block-footer.tsx"
    },
    {
      "path": "components/grid/block-toolbar.tsx",
      "type": "registry:component",
      "content": "import { forwardRef } from 'react'\nimport { cn } from \"@/lib/utils\"\n\nexport interface BlockToolbarProps {\n  left?: React.ReactNode\n  center?: React.ReactNode\n  right?: React.ReactNode\n  className?: string\n  'aria-label'?: string\n}\n\n/**\n * BlockToolbar component for standardized toolbar layouts\n * Provides left, center, and right sections with proper spacing\n */\nexport const BlockToolbar = forwardRef<HTMLDivElement, BlockToolbarProps>(\n  ({ left, center, right, className, 'aria-label': ariaLabel }, ref) => {\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          'pretty-poly-block-toolbar',\n          'flex items-center justify-between',\n          'w-full px-3 py-2', // Standard padding\n          'border-b', // Shadcn border uses default border color\n          'bg-muted', // Shadcn background\n          className\n        )}\n        aria-label={ariaLabel || 'Toolbar'}\n        role=\"toolbar\"\n      >\n        {/* Left section */}\n        <div className=\"flex items-center space-x-2 flex-shrink-0\">\n          {left}\n        </div>\n\n        {/* Center section */}\n        <div className=\"flex items-center justify-center flex-1 px-4\">\n          {center}\n        </div>\n\n        {/* Right section */}\n        <div className=\"flex items-center space-x-2 flex-shrink-0\">\n          {right}\n        </div>\n      </div>\n    )\n  }\n)\n\nBlockToolbar.displayName = 'Block.Toolbar'",
      "target": "components/grid/block-toolbar.tsx"
    },
    {
      "path": "components/grid/block-layout.tsx",
      "type": "registry:component",
      "content": "import { forwardRef } from 'react'\nimport { cn } from \"@/lib/utils\"\n\nexport interface BlockLayoutProps {\n  direction?: 'row' | 'column'\n  className?: string\n  children: React.ReactNode\n  'aria-label'?: string\n}\n\n/**\n * BlockLayout component provides flex container for structured block content\n * Use this to wrap BlockHeader, BlockContent, BlockFooter, and BlockSidebar components\n */\nexport const BlockLayout = forwardRef<HTMLDivElement, BlockLayoutProps>(\n  ({ direction = 'column', className, children, 'aria-label': ariaLabel }, ref) => {\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          'pretty-poly-block-layout',\n          // Fill parent block completely\n          'w-full h-full',\n          // Flex container for structured children\n          'flex',\n          direction === 'column' ? 'flex-col' : 'flex-row',\n          // Allow flex children to shrink below content size\n          'min-h-0 min-w-0',\n          // Stretch to fill grid area\n          'self-stretch',\n          className\n        )}\n        aria-label={ariaLabel}\n      >\n        {children}\n      </div>\n    )\n  }\n)\n\nBlockLayout.displayName = 'Block.Layout'\n",
      "target": "components/grid/block-layout.tsx"
    },
    {
      "path": "components/divider/divider.tsx",
      "type": "registry:component",
      "content": "import React, { useRef, useCallback, useState, useLayoutEffect, useEffect } from 'react'\nimport { cn } from \"@/lib/utils\"\nimport { useGridState, useGridResize } from \"@/components/grid/grid-provider\"\n\ninterface DividerProps {\n  targetId: string\n  position: 'start' | 'end'\n  direction: 'vertical' | 'horizontal'\n  size?: number\n  className?: string\n  'aria-label'?: string\n}\n\n/**\n * Absolutely positioned divider overlay component\n * Positioned using getBoundingClientRect for accuracy\n */\nexport const Divider: React.FC<DividerProps> = ({\n  targetId,\n  position,\n  direction,\n  size = 4, // Default hover zone size (like VS Code)\n  className,\n  'aria-label': ariaLabel\n}) => {\n  const dividerRef = useRef<HTMLDivElement>(null)\n  const state = useGridState()\n  const { startResize, isDragging, activeDividerId } = useGridResize()\n\n  const [dividerPosition, setDividerPosition] = useState({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0\n  })\n\n  const targetBlock = state.blocks[targetId]\n  const isVertical = direction === 'vertical'\n  const dividerId = `${targetId}-${position}-divider`\n  const isActive = isDragging && activeDividerId === dividerId\n\n  /**\n   * Calculate and update divider position based on block boundaries\n   */\n  const updatePosition = useCallback(() => {\n    // Find the grid container (has data-grid-id)\n    const gridContainer = document.querySelector('[data-grid-id]') as HTMLElement\n    const targetElement = document.querySelector(`[data-block-id=\"${targetId}\"]`) as HTMLElement\n\n    if (!gridContainer || !targetElement) return\n\n    const containerRect = gridContainer.getBoundingClientRect()\n    const blockRect = targetElement.getBoundingClientRect()\n\n    // Find parent block to constrain divider dimensions for nested blocks\n    const parentId = targetBlock?.parentId\n    const parentElement = parentId\n      ? document.querySelector(`[data-block-id=\"${parentId}\"]`) as HTMLElement\n      : gridContainer\n\n    if (!parentElement) return\n\n    const parentRect = parentElement.getBoundingClientRect()\n\n    if (isVertical) {\n      // Vertical divider - positioned on left or right edge of block\n      const edgePosition = position === 'start'\n        ? blockRect.left - containerRect.left\n        : blockRect.right - containerRect.left\n\n      setDividerPosition({\n        left: edgePosition - (size / 2), // Center on edge\n        top: parentRect.top - containerRect.top, // Position relative to parent\n        width: size,\n        height: parentRect.height // Use parent height to constrain divider\n      })\n    } else {\n      // Horizontal divider - positioned on top or bottom edge of block\n      const edgePosition = position === 'start'\n        ? blockRect.top - containerRect.top\n        : blockRect.bottom - containerRect.top\n\n      setDividerPosition({\n        left: parentRect.left - containerRect.left, // Position relative to parent\n        top: edgePosition - (size / 2), // Center on edge\n        width: parentRect.width, // Use parent width to constrain divider\n        height: size\n      })\n    }\n  }, [targetId, position, isVertical, size, targetBlock?.parentId])\n\n  /**\n   * Set up ResizeObserver to track block and container size changes\n   */\n  useLayoutEffect(() => {\n    const gridContainer = document.querySelector('[data-grid-id]') as HTMLElement\n    const targetElement = document.querySelector(`[data-block-id=\"${targetId}\"]`) as HTMLElement\n\n    if (!gridContainer || !targetElement) return\n\n    // Initial position\n    updatePosition()\n\n    // Watch for size changes\n    const resizeObserver = new ResizeObserver(() => {\n      updatePosition()\n    })\n\n    resizeObserver.observe(gridContainer)\n    resizeObserver.observe(targetElement)\n\n    // Also observe parent element if it exists (for nested blocks)\n    const parentId = targetBlock?.parentId\n    const parentElement = parentId\n      ? document.querySelector(`[data-block-id=\"${parentId}\"]`) as HTMLElement\n      : null\n\n    if (parentElement) {\n      resizeObserver.observe(parentElement)\n    }\n\n    return () => {\n      resizeObserver.disconnect()\n    }\n  }, [targetId, updatePosition, targetBlock?.parentId])\n\n  /**\n   * Also update position when blocks change (resize operations)\n   */\n  useEffect(() => {\n    updatePosition()\n  }, [state.blocks, updatePosition])\n\n  /**\n   * Handle resize start\n   */\n  const handlePointerDown = useCallback((event: React.MouseEvent | React.TouchEvent) => {\n    event.preventDefault()\n    startResize(targetId, dividerId, event)\n  }, [targetId, dividerId, startResize])\n\n  if (!targetBlock) {\n    return null\n  }\n\n  return (\n    <div\n      ref={dividerRef}\n      className={cn(\n        'pretty-poly-divider',\n        'absolute',\n        'bg-transparent', // Invisible by default\n        'transition-colors duration-100',\n        'hover:bg-[var(--divider-hover-color,rgba(59,130,246,0.5))]',\n        isActive && 'bg-[var(--divider-active-color,rgba(59,130,246,0.7))]',\n        isVertical ? 'cursor-col-resize' : 'cursor-row-resize',\n        className\n      )}\n      style={{\n        left: `${dividerPosition.left}px`,\n        top: `${dividerPosition.top}px`,\n        width: `${dividerPosition.width}px`,\n        height: `${dividerPosition.height}px`,\n        pointerEvents: 'auto', // Re-enable pointer events (parent has pointer-events: none)\n        zIndex: 10\n      }}\n      data-divider-id={dividerId}\n      data-target-block={targetId}\n      data-divider-position={position}\n      data-divider-direction={direction}\n      role=\"separator\"\n      aria-label={ariaLabel || `Resize ${targetId}`}\n      aria-valuenow={targetBlock?.defaultSize}\n      aria-valuemin={targetBlock?.minSize}\n      aria-valuemax={targetBlock?.maxSize}\n      tabIndex={0}\n      onMouseDown={handlePointerDown}\n      onTouchStart={handlePointerDown}\n    />\n  )\n}\n\nDivider.displayName = 'Divider'\n",
      "target": "components/divider/divider.tsx"
    },
    {
      "path": "components/divider/divider-overlay.tsx",
      "type": "registry:component",
      "content": "import React, { useMemo } from 'react'\nimport { useGridState } from \"@/components/grid/grid-provider\"\nimport { Divider } from \"@/components/divider/divider\"\nimport { autoDetectDividerPosition } from \"@/lib/grid-divider-auto-detection\"\nimport type { BlockConfig } from \"@/lib/grid-types\"\n\ninterface DividerInfo {\n  id: string\n  targetBlockId: string\n  position: 'start' | 'end'\n  direction: 'vertical' | 'horizontal'\n}\n\n/**\n * Auto-generates dividers based on block configuration\n * Uses smart position detection to determine which block should be resized\n */\nfunction generateDividers(blocks: Record<string, BlockConfig>): DividerInfo[] {\n  const dividers: DividerInfo[] = []\n\n  // Find all group blocks\n  const groups = Object.values(blocks).filter(block => block.type === 'group')\n\n  groups.forEach(group => {\n    // Get children of this group, sorted by order\n    const children = Object.values(blocks)\n      .filter(block => block.parentId === group.id)\n      .sort((a, b) => (a.order || 0) - (b.order || 0))\n\n    if (children.length === 0) return\n\n    const isHorizontal = group.direction === 'row'\n    const dividerDirection: 'vertical' | 'horizontal' = isHorizontal ? 'vertical' : 'horizontal'\n\n    // Create divider between each pair of children\n    children.forEach((child, index) => {\n      if (index === 0) return // No divider before first child\n\n      const previousChild = children[index - 1]\n\n      // Use smart detection to determine which block should be the target\n      const { targetId, position } = autoDetectDividerPosition(previousChild, child)\n\n      dividers.push({\n        id: `divider-${previousChild.id}-${child.id}`,\n        targetBlockId: targetId,\n        position: position as 'start' | 'end',\n        direction: dividerDirection\n      })\n    })\n  })\n\n  return dividers\n}\n\n/**\n * Overlay container that manages all dividers as absolutely positioned elements\n */\nexport const DividerOverlay: React.FC = () => {\n  const state = useGridState()\n\n  // Auto-generate dividers from block configuration\n  const dividers = useMemo(() => {\n    return generateDividers(state.blocks)\n  }, [state.blocks])\n\n  if (dividers.length === 0) {\n    return null\n  }\n\n  return (\n    <div\n      className=\"pretty-poly-divider-overlay\"\n      style={{\n        position: 'absolute',\n        inset: 0,\n        pointerEvents: 'none',\n        zIndex: 10\n      }}\n    >\n      {dividers.map(divider => (\n        <Divider\n          key={divider.id}\n          targetId={divider.targetBlockId}\n          position={divider.position}\n          direction={divider.direction}\n        />\n      ))}\n    </div>\n  )\n}\n",
      "target": "components/divider/divider-overlay.tsx"
    },
    {
      "path": "hooks/use-grid-resize.ts",
      "type": "registry:hook",
      "content": "import { useCallback, useEffect } from 'react'\nimport type { BlockConfig, Direction } from \"@/lib/grid-types\"\nimport { useGridResize as useGridResizeContext } from \"@/components/grid/grid-provider\"\nimport { getFlexSpacePx } from \"@/lib/grid-calculations\"\n\nexport interface UseGridResizeOptions {\n  blocks: BlockConfig[]\n  containerRef: React.RefObject<HTMLElement>\n  onSizeChange?: (blockId: string, newSize: number) => void\n  direction?: Direction\n}\n\n/**\n * Hook for handling grid resize operations\n * Now uses the context-based resize system instead of managing state locally\n */\nexport function useGridResize({\n  blocks,\n  containerRef,\n  onSizeChange,\n  direction = 'row'\n}: UseGridResizeOptions) {\n  const {\n    startResize,\n    updateResize,\n    endResize,\n    isDragging,\n    activeBlockId,\n    activeDividerId\n  } = useGridResizeContext()\n\n  /**\n   * Get container size in the relevant dimension\n   */\n  const getContainerSize = useCallback((): number => {\n    if (!containerRef.current) return 0\n\n    const rect = containerRef.current.getBoundingClientRect()\n    return direction === 'column' ? rect.width : rect.height\n  }, [direction, containerRef])\n\n  /**\n   * Calculate pixels per fr unit for the current container\n   * Note: Dividers are now overlays and don't take up grid space\n   */\n  const calculatePixelsPerFr = useCallback((): number => {\n    const containerSize = getContainerSize()\n    if (containerSize === 0) return 0\n\n    // Calculate fixed space (px blocks only - dividers are overlays now)\n    const fixedSpace = blocks\n      .filter(block => block.sizeUnit === 'px')\n      .reduce((sum, block) => sum + (block.defaultSize || 0), 0)\n\n    // No gap space - dividers are overlays\n    const gapSpace = 0\n\n    // Calculate total fr units\n    const totalFr = blocks\n      .filter(block => block.sizeUnit === 'fr')\n      .reduce((sum, block) => sum + (block.defaultSize || 1), 0)\n\n    const flexSpace = getFlexSpacePx(containerSize, fixedSpace, gapSpace)\n    return totalFr > 0 ? flexSpace / totalFr : 0\n  }, [blocks, getContainerSize])\n\n  /**\n   * Reset a block to its default size\n   */\n  const resetBlock = useCallback((blockId: string) => {\n    const block = blocks.find(b => b.id === blockId)\n    if (block && block.defaultSize !== undefined) {\n      onSizeChange?.(blockId, block.defaultSize)\n    }\n  }, [blocks, onSizeChange])\n\n  /**\n   * Collapse a block\n   */\n  const collapseBlock = useCallback((blockId: string) => {\n    const block = blocks.find(b => b.id === blockId)\n    if (block && block.collapseTo !== undefined) {\n      onSizeChange?.(blockId, block.collapseTo)\n    }\n  }, [blocks, onSizeChange])\n\n  /**\n   * Expand a collapsed block\n   */\n  const expandBlock = useCallback((blockId: string) => {\n    const block = blocks.find(b => b.id === blockId)\n    if (block && block.defaultSize !== undefined) {\n      onSizeChange?.(blockId, block.defaultSize)\n    }\n  }, [blocks, onSizeChange])\n\n  /**\n   * Check if a block is collapsed\n   */\n  const isBlockCollapsed = useCallback((blockId: string): boolean => {\n    const block = blocks.find(b => b.id === blockId)\n    if (!block || !block.collapseAt) return false\n\n    return (block.defaultSize || 0) <= block.collapseAt\n  }, [blocks])\n\n  // Set up global event listeners for resize operations\n  useEffect(() => {\n    const handleMouseMove = (e: MouseEvent) => {\n      e.preventDefault()\n      updateResize(e)\n    }\n\n    const handleTouchMove = (e: TouchEvent) => {\n      e.preventDefault()\n      updateResize(e)\n    }\n\n    const handleMouseUp = () => {\n      endResize()\n    }\n\n    const handleTouchEnd = () => {\n      endResize()\n    }\n\n    if (isDragging) {\n      document.addEventListener('mousemove', handleMouseMove)\n      document.addEventListener('mouseup', handleMouseUp)\n      document.addEventListener('touchmove', handleTouchMove)\n      document.addEventListener('touchend', handleTouchEnd)\n\n      return () => {\n        document.removeEventListener('mousemove', handleMouseMove)\n        document.removeEventListener('mouseup', handleMouseUp)\n        document.removeEventListener('touchmove', handleTouchMove)\n        document.removeEventListener('touchend', handleTouchEnd)\n      }\n    }\n  }, [isDragging, updateResize, endResize])\n\n  return {\n    // State\n    isDragging,\n    activeBlockId,\n    activeDividerId,\n\n    // Actions\n    startResize,\n    resetBlock,\n    collapseBlock,\n    expandBlock,\n\n    // Utilities\n    isBlockCollapsed,\n    getContainerSize,\n    calculatePixelsPerFr\n  }\n}",
      "target": "hooks/use-grid-resize.ts"
    },
    {
      "path": "hooks/use-grid-resize-operations.ts",
      "type": "registry:hook",
      "content": "import { useCallback } from 'react'\nimport type { GridState, GridAction } from \"@/lib/grid-types\"\nimport { calculateConstrainedSize, getFlexSpacePx, pxToFr } from \"@/lib/grid-calculations\"\n\n/**\n * Hook for managing grid resize operations\n * Extracted from GridProvider to reduce complexity and improve testability\n */\nexport function useGridResizeOperations(\n  state: GridState,\n  dispatch: React.Dispatch<GridAction>\n) {\n  /**\n   * Extract position from mouse or touch event\n   */\n  const getEventPosition = useCallback((\n    event: MouseEvent | TouchEvent | React.MouseEvent | React.TouchEvent\n  ): { x: number; y: number } => {\n    if (\"touches\" in event) {\n      return {\n        x: event.touches[0].clientX,\n        y: event.touches[0].clientY,\n      };\n    }\n    return {\n      x: event.clientX,\n      y: event.clientY,\n    };\n  }, []);\n\n  /**\n   * Start a resize operation\n   */\n  const startResize = useCallback((\n    blockId: string,\n    dividerId: string,\n    event: React.MouseEvent | React.TouchEvent\n  ) => {\n    const block = state.blocks[blockId];\n    if (!block) return;\n\n    const startPosition = getEventPosition(event);\n\n    // Get the divider position from the DOM\n    const dividerEl = document.querySelector(`[data-divider-id=\"${dividerId}\"]`);\n    const dividerPosition = dividerEl?.getAttribute('data-divider-position') as 'start' | 'end' || 'end';\n\n    // Find adjacent block for two-way resizing\n    const siblingBlocks = Object.values(state.blocks).filter(\n      (b) => b.parentId === block.parentId\n    );\n    const sortedSiblings = siblingBlocks.sort(\n      (a, b) => (a.order || 0) - (b.order || 0)\n    );\n    const blockIndex = sortedSiblings.findIndex((b) => b.id === blockId);\n\n    let adjacentBlock = null;\n    if (dividerPosition === \"start\" && blockIndex > 0) {\n      adjacentBlock = sortedSiblings[blockIndex - 1];\n    } else if (\n      dividerPosition === \"end\" &&\n      blockIndex < sortedSiblings.length - 1\n    ) {\n      adjacentBlock = sortedSiblings[blockIndex + 1];\n    }\n\n    // Validation: Prevent resizing fr blocks when adjacent to px blocks\n    if (\n      adjacentBlock &&\n      block.sizeUnit === \"fr\" &&\n      adjacentBlock.sizeUnit === \"px\"\n    ) {\n      console.warn(\n        `Cannot resize fr block \"${blockId}\" when adjacent to px block \"${adjacentBlock.id}\". Fr blocks fill available space and should not be directly resized. Consider resizing the px block instead.`\n      );\n      return;\n    }\n\n    dispatch({\n      type: \"START_RESIZE\",\n      payload: {\n        blockId,\n        dividerId,\n        startPosition,\n        initialSize: block.defaultSize || 0,\n        initialAdjacentBlockId: adjacentBlock?.id,\n        initialAdjacentSize: adjacentBlock\n          ? adjacentBlock.originalDefaultSize ||\n            adjacentBlock.defaultSize ||\n            0\n          : undefined,\n      },\n    });\n\n    // Prevent text selection during drag\n    document.body.style.userSelect = \"none\";\n    const parentBlock = block.parentId\n      ? state.blocks[block.parentId]\n      : null;\n    const direction = parentBlock?.direction || \"row\";\n    document.body.style.cursor =\n      direction === \"row\" ? \"col-resize\" : \"row-resize\";\n  }, [state.blocks, dispatch, getEventPosition]);\n\n  /**\n   * Update resize during drag\n   */\n  const updateResize = useCallback((event: MouseEvent | TouchEvent) => {\n    if (!state.resize.isDragging || !state.resize.activeBlockId) return;\n\n    const block = state.blocks[state.resize.activeBlockId];\n    if (!block) return;\n\n    const currentPosition = getEventPosition(event);\n\n    // Find the parent block to determine the resize direction\n    const parentBlock = block.parentId\n      ? state.blocks[block.parentId]\n      : null;\n    const direction = parentBlock?.direction || \"row\";\n\n    // Calculate delta based on the parent's direction\n    // If parent arranges children in 'row', dividers move horizontally (X axis)\n    // If parent arranges children in 'column', dividers move vertically (Y axis)\n    const deltaPx =\n      direction === \"row\"\n        ? currentPosition.x - state.resize.startPosition.x\n        : currentPosition.y - state.resize.startPosition.y;\n\n    if (block.sizeUnit === \"px\") {\n      // Handle pixel-based resizing\n      // Get position from divider's data attribute\n      const dividerEl = document.querySelector(`[data-divider-id=\"${state.resize.activeDividerId}\"]`);\n      const dividerPosition = dividerEl?.getAttribute('data-divider-position') || 'end';\n\n      // For position=\"start\": divider is BEFORE the block\n      // - Dragging left (negative delta) should GROW the block (need inversion)\n      // - Dragging right (positive delta) should SHRINK the block (need inversion)\n      // For position=\"end\": divider is AFTER the block\n      // - Dragging right (positive delta) should GROW the block (no inversion)\n      // - Dragging left (negative delta) should SHRINK the block (no inversion)\n      const shouldInvertDelta = dividerPosition === \"start\";\n\n      const newSize = calculateConstrainedSize(\n        deltaPx,\n        state.resize.initialSize,\n        block.minSize,\n        block.maxSize,\n        shouldInvertDelta\n      );\n\n      dispatch({\n        type: \"RESIZE_BLOCK\",\n        payload: { blockId: state.resize.activeBlockId, size: newSize },\n      });\n    } else if (block.sizeUnit === \"fr\") {\n      // Handle fractional resizing (two-way)\n      const siblingBlocks = Object.values(state.blocks).filter(\n        (b) => b.parentId === block.parentId\n      );\n      const frBlocks = siblingBlocks.filter((b) => b.sizeUnit === \"fr\");\n\n      // Measure the actual parent container dimensions\n      const parentElement = block.parentId\n        ? document.querySelector(`[data-block-id=\"${block.parentId}\"]`)\n        : document.querySelector(`[data-block-id=\"root\"]`);\n\n      const containerSize = parentElement\n        ? direction === \"row\"\n          ? parentElement.clientWidth\n          : parentElement.clientHeight\n        : 1200; // Fallback only if element not found\n      // Measure actual pixel space used by px blocks (not configured defaultSize)\n      const pxBlocks = siblingBlocks\n        .filter((b) => b.sizeUnit === \"px\")\n        .reduce((sum, b) => {\n          const el = document.querySelector(`[data-block-id=\"${b.id}\"]`);\n          if (!el) return sum;\n          const size =\n            direction === \"row\" ? el.clientWidth : el.clientHeight;\n          return sum + size;\n        }, 0);\n\n      // Measure actual divider sizes from DOM (not calculated count × 8px)\n      const dividers = Array.from(\n        parentElement?.querySelectorAll('[data-block-type=\"divider\"]') || []\n      );\n      const gapSpace = dividers.reduce((sum, el) => {\n        if (!(el instanceof HTMLElement)) return sum;\n        const size = direction === \"row\" ? el.clientWidth : el.clientHeight;\n        return sum + size;\n      }, 0);\n\n      const fixedSpace = pxBlocks;\n      const flexSpace = getFlexSpacePx(containerSize, fixedSpace, gapSpace);\n      // Use current sizes, not original defaults, for accurate calculations during multi-step resizes\n      const totalFr = frBlocks.reduce(\n        (sum, b) => sum + (b.defaultSize || 1),\n        0\n      );\n      const pixelsPerFr = totalFr > 0 ? flexSpace / totalFr : 0;\n\n      if (pixelsPerFr === 0) return; // Prevent division by zero\n\n      const deltaFr = pxToFr(deltaPx, pixelsPerFr);\n\n      // Find adjacent block based on block order\n      const sortedFrBlocks = frBlocks.sort(\n        (a, b) => (a.order || 0) - (b.order || 0)\n      );\n      const blockIndex = sortedFrBlocks.findIndex(\n        (b) => b.id === state.resize.activeBlockId\n      );\n\n      // Get actual position from divider's data attribute first\n      const dividerEl = document.querySelector(`[data-divider-id=\"${state.resize.activeDividerId}\"]`);\n      const dividerPosition = dividerEl?.getAttribute('data-divider-position') || 'end';\n\n      let adjacentBlock = null;\n      if (dividerPosition === \"start\" && blockIndex > 0) {\n        adjacentBlock = sortedFrBlocks[blockIndex - 1];\n      } else if (\n        dividerPosition === \"end\" &&\n        blockIndex < sortedFrBlocks.length - 1\n      ) {\n        adjacentBlock = sortedFrBlocks[blockIndex + 1];\n      }\n\n      if (adjacentBlock) {\n        let targetDelta: number;\n        let adjacentDelta: number;\n\n        if (dividerPosition === \"start\") {\n          // Divider at start: moving right grows target, shrinks previous\n          targetDelta = deltaFr;\n          adjacentDelta = -deltaFr;\n        } else {\n          // Divider at end: moving right grows target, shrinks next\n          targetDelta = deltaFr;\n          adjacentDelta = -deltaFr;\n        }\n\n        // Apply minimum size constraints using initial sizes\n        const minSize = 0.1; // Minimum fr size\n        const newTargetSize = Math.max(\n          minSize,\n          state.resize.initialSize + targetDelta\n        );\n        const newAdjacentSize = Math.max(\n          minSize,\n          (state.resize.initialAdjacentSize || 1) + adjacentDelta\n        );\n\n        // Ensure zero-sum by adjusting if constraints were applied\n        const actualTargetDelta = newTargetSize - state.resize.initialSize;\n        const actualAdjacentDelta =\n          newAdjacentSize - (state.resize.initialAdjacentSize || 1);\n\n        if (Math.abs(actualTargetDelta + actualAdjacentDelta) < 0.01) {\n          dispatch({\n            type: \"RESIZE_BLOCK\",\n            payload: {\n              blockId: state.resize.activeBlockId,\n              size: newTargetSize,\n            },\n          });\n          dispatch({\n            type: \"RESIZE_BLOCK\",\n            payload: { blockId: adjacentBlock.id, size: newAdjacentSize },\n          });\n        }\n      }\n    }\n  }, [state.resize, state.blocks, dispatch, getEventPosition]);\n\n  /**\n   * End resize operation and cleanup\n   */\n  const endResize = useCallback(() => {\n    dispatch({ type: \"END_RESIZE\" });\n\n    // Restore normal cursor and text selection\n    document.body.style.userSelect = \"\";\n    document.body.style.cursor = \"\";\n  }, [dispatch]);\n\n  return {\n    startResize,\n    updateResize,\n    endResize,\n  };\n}\n",
      "target": "hooks/use-grid-resize-operations.ts"
    },
    {
      "path": "hooks/use-grid-mode.ts",
      "type": "registry:hook",
      "content": "import { useState, useEffect, useCallback, useMemo } from 'react'\nimport type { ResponsiveModes, LayoutMode, ViewportInfo } from \"@/lib/grid-types\"\n\n/**\n * Default responsive mode configurations\n */\nexport const defaultModes: ResponsiveModes = {\n  mobile: {\n    type: 'dock',\n    breakpoint: 0,\n    maxWidth: 767\n  },\n  tablet: {\n    type: 'tabs',\n    breakpoint: 768,\n    minWidth: 768,\n    maxWidth: 1023\n  },\n  desktop: {\n    type: 'grid',\n    breakpoint: 1024,\n    minWidth: 1024\n  }\n}\n\n/**\n * Hook for managing responsive grid modes\n */\nexport function useGridMode(modes: ResponsiveModes = defaultModes) {\n  const [viewport, setViewport] = useState<ViewportInfo>(() => {\n    if (typeof window === 'undefined') {\n      return { width: 1024, height: 768, orientation: 'landscape' }\n    }\n\n    return {\n      width: window.innerWidth,\n      height: window.innerHeight,\n      orientation: window.innerWidth > window.innerHeight ? 'landscape' : 'portrait'\n    }\n  })\n\n  const [forcedMode, setForcedMode] = useState<string | null>(null)\n\n  /**\n   * Update viewport information\n   */\n  const updateViewport = useCallback(() => {\n    if (typeof window === 'undefined') return\n\n    const newViewport: ViewportInfo = {\n      width: window.innerWidth,\n      height: window.innerHeight,\n      orientation: window.innerWidth > window.innerHeight ? 'landscape' : 'portrait'\n    }\n\n    setViewport(newViewport)\n  }, [])\n\n  /**\n   * Find the active mode based on current viewport and modes configuration\n   */\n  const activeMode = useMemo(() => {\n    if (forcedMode && modes[forcedMode]) {\n      return forcedMode\n    }\n\n    // Find the best matching mode\n    const matchingModes = Object.entries(modes).filter(([_, config]) => {\n      // If mode has a custom matcher, use it\n      if (config.matcher) {\n        return config.matcher(viewport)\n      }\n\n      // Otherwise use breakpoint logic\n      const matchesMin = !config.minWidth || viewport.width >= config.minWidth\n      const matchesMax = !config.maxWidth || viewport.width <= config.maxWidth\n\n      return matchesMin && matchesMax\n    })\n\n    // Sort by specificity (modes with both min and max are more specific)\n    matchingModes.sort(([, a], [, b]) => {\n      const aSpecific = (a.minWidth ? 1 : 0) + (a.maxWidth ? 1 : 0)\n      const bSpecific = (b.minWidth ? 1 : 0) + (b.maxWidth ? 1 : 0)\n      return bSpecific - aSpecific\n    })\n\n    // Return the most specific matching mode, or fall back to first available\n    return matchingModes[0]?.[0] || Object.keys(modes)[0] || 'desktop'\n  }, [viewport, modes, forcedMode])\n\n  /**\n   * Get the current mode configuration\n   */\n  const currentModeConfig = useMemo(() => {\n    return modes[activeMode]\n  }, [modes, activeMode])\n\n  /**\n   * Get the current layout type\n   */\n  const currentLayoutType = useMemo(() => {\n    return currentModeConfig?.type || 'grid'\n  }, [currentModeConfig])\n\n  /**\n   * Force a specific mode (useful for testing or user preference)\n   */\n  const setMode = useCallback((modeName: string | null) => {\n    if (modeName && !modes[modeName]) {\n      console.warn(`Mode \"${modeName}\" not found in configuration`)\n      return\n    }\n    setForcedMode(modeName)\n  }, [modes])\n\n  /**\n   * Check if a specific mode is currently active\n   */\n  const isMode = useCallback((modeName: string) => {\n    return activeMode === modeName\n  }, [activeMode])\n\n  /**\n   * Get all available mode names\n   */\n  const availableModes = useMemo(() => {\n    return Object.keys(modes)\n  }, [modes])\n\n  /**\n   * Check if the current mode supports a specific feature\n   */\n  const supportsFeature = useCallback((feature: 'resizing' | 'dividers' | 'collapse' | 'tabs' | 'dock'): boolean => {\n    switch (currentLayoutType) {\n      case 'grid':\n        return ['resizing', 'dividers', 'collapse'].includes(feature)\n      case 'tabs':\n        return feature === 'tabs'\n      case 'dock':\n        return feature === 'dock'\n      default:\n        return false\n    }\n  }, [currentLayoutType])\n\n  /**\n   * Get responsive breakpoint information\n   */\n  const breakpointInfo = useMemo(() => {\n    const sortedModes = Object.entries(modes)\n      .map(([name, config]) => ({ name, ...config }))\n      .sort((a, b) => (a.breakpoint || 0) - (b.breakpoint || 0))\n\n    const currentIndex = sortedModes.findIndex(mode => mode.name === activeMode)\n    const nextMode = sortedModes[currentIndex + 1]\n    const prevMode = sortedModes[currentIndex - 1]\n\n    return {\n      current: activeMode,\n      currentBreakpoint: currentModeConfig?.breakpoint || 0,\n      nextMode: nextMode?.name,\n      nextBreakpoint: nextMode?.breakpoint,\n      prevMode: prevMode?.name,\n      prevBreakpoint: prevMode?.breakpoint,\n      isSmallest: currentIndex === 0,\n      isLargest: currentIndex === sortedModes.length - 1\n    }\n  }, [modes, activeMode, currentModeConfig])\n\n  // Set up viewport change listener\n  useEffect(() => {\n    if (typeof window === 'undefined') return\n\n    const handleResize = () => updateViewport()\n    const handleOrientationChange = () => {\n      // Delay to allow orientation change to complete\n      setTimeout(updateViewport, 100)\n    }\n\n    window.addEventListener('resize', handleResize)\n    window.addEventListener('orientationchange', handleOrientationChange)\n\n    return () => {\n      window.removeEventListener('resize', handleResize)\n      window.removeEventListener('orientationchange', handleOrientationChange)\n    }\n  }, [updateViewport])\n\n  return {\n    // Current state\n    viewport,\n    activeMode,\n    currentModeConfig,\n    currentLayoutType: currentLayoutType as LayoutMode,\n\n    // Mode management\n    setMode,\n    isMode,\n    availableModes,\n\n    // Features and capabilities\n    supportsFeature,\n    breakpointInfo,\n\n    // Utilities\n    isForced: !!forcedMode,\n    updateViewport\n  }\n}",
      "target": "hooks/use-grid-mode.ts"
    },
    {
      "path": "hooks/use-grid-persistence.ts",
      "type": "registry:hook",
      "content": "import { useCallback, useEffect, useRef } from 'react'\nimport type { GridState } from \"@/lib/grid-types\"\nimport {\n  getStorageAdapter,\n  saveGridState,\n  loadGridState,\n  removeGridState,\n  createCustomAdapter,\n  type StorageAdapter\n} from \"@/lib/grid-storage\"\n\nexport interface UseGridPersistenceOptions {\n  gridId: string\n  enabled: boolean | 'localStorage' | 'sessionStorage' | ((state: GridState) => void)\n  state: GridState\n  onStateLoad?: (state: Partial<GridState>) => void\n  autoSave?: boolean\n  saveDelay?: number\n}\n\n/**\n * Hook for handling grid state persistence\n */\nexport function useGridPersistence({\n  gridId,\n  enabled,\n  state,\n  onStateLoad,\n  autoSave = true,\n  saveDelay = 500\n}: UseGridPersistenceOptions) {\n  const storageAdapter = useRef<StorageAdapter | null>(null)\n  const saveTimeoutRef = useRef<NodeJS.Timeout>()\n  const lastSavedState = useRef<string>('')\n  const hasLoadedRef = useRef<boolean>(false)\n\n  // Initialize storage adapter\n  useEffect(() => {\n    if (!enabled) {\n      storageAdapter.current = null\n      return\n    }\n\n    if (typeof enabled === 'function') {\n      // Custom save function\n      storageAdapter.current = createCustomAdapter(enabled)\n    } else if (enabled === 'localStorage') {\n      storageAdapter.current = getStorageAdapter('localStorage')\n    } else if (enabled === 'sessionStorage') {\n      storageAdapter.current = getStorageAdapter('sessionStorage')\n    } else {\n      // Default to localStorage\n      storageAdapter.current = getStorageAdapter('localStorage')\n    }\n  }, [enabled])\n\n  /**\n   * Load persisted state on mount\n   */\n  useEffect(() => {\n    if (!storageAdapter.current || !enabled || typeof enabled === 'function' || hasLoadedRef.current) {\n      return\n    }\n\n    const loadedState = loadGridState(gridId, storageAdapter.current)\n    if (loadedState) {\n      onStateLoad?.(loadedState)\n      hasLoadedRef.current = true\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [gridId, enabled]) // onStateLoad is intentionally stable (not expected to change)\n\n  /**\n   * Save state to storage\n   */\n  const saveState = useCallback((stateToSave: GridState = state) => {\n    if (!storageAdapter.current || !enabled) {\n      return\n    }\n\n    // Don't save if state hasn't changed\n    const stateString = JSON.stringify(stateToSave)\n    if (stateString === lastSavedState.current) {\n      return\n    }\n\n    try {\n      saveGridState(gridId, stateToSave, storageAdapter.current)\n      lastSavedState.current = stateString\n    } catch (error) {\n      console.warn('Failed to save grid state:', error)\n    }\n  }, [gridId, enabled, state])\n\n  /**\n   * Save state with debouncing\n   */\n  const debouncedSave = useCallback((stateToSave: GridState = state) => {\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current)\n    }\n\n    saveTimeoutRef.current = setTimeout(() => {\n      saveState(stateToSave)\n    }, saveDelay)\n  }, [saveState, saveDelay, state])\n\n  /**\n   * Clear persisted state\n   */\n  const clearState = useCallback(() => {\n    if (!storageAdapter.current || !enabled || typeof enabled === 'function') {\n      return\n    }\n\n    try {\n      removeGridState(gridId, storageAdapter.current)\n      lastSavedState.current = ''\n    } catch (error) {\n      console.warn('Failed to clear grid state:', error)\n    }\n  }, [gridId, enabled])\n\n  /**\n   * Force immediate save\n   */\n  const forceSave = useCallback((stateToSave: GridState = state) => {\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current)\n    }\n    saveState(stateToSave)\n  }, [saveState, state])\n\n  // Auto-save when state changes\n  useEffect(() => {\n    if (!autoSave || !enabled) {\n      return\n    }\n\n    debouncedSave(state)\n\n    // Cleanup timeout on unmount\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n      }\n    }\n  }, [state, autoSave, enabled, debouncedSave])\n\n  // Save state before page unload\n  useEffect(() => {\n    if (!enabled || typeof enabled === 'function') {\n      return\n    }\n\n    const handleBeforeUnload = () => {\n      forceSave()\n    }\n\n    window.addEventListener('beforeunload', handleBeforeUnload)\n    return () => {\n      window.removeEventListener('beforeunload', handleBeforeUnload)\n    }\n  }, [forceSave, enabled])\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n      }\n    }\n  }, [])\n\n  return {\n    saveState: forceSave,\n    debouncedSave,\n    clearState,\n    isEnabled: !!enabled\n  }\n}",
      "target": "hooks/use-grid-persistence.ts"
    },
    {
      "path": "hooks/use-grid-keyboard.ts",
      "type": "registry:hook",
      "content": "import { useCallback, useEffect } from 'react'\nimport type { BlockConfig } from \"@/lib/grid-types\"\n\nexport interface UseGridKeyboardOptions {\n  enabled?: boolean\n  blocks: BlockConfig[]\n  onResizeBlock?: (blockId: string, delta: number) => void\n  onFocusBlock?: (blockId: string) => void\n  onCollapseBlock?: (blockId: string) => void\n  onExpandBlock?: (blockId: string) => void\n  containerRef?: React.RefObject<HTMLElement>\n  stepSize?: number\n  largeStepSize?: number\n}\n\n/**\n * Hook for keyboard navigation and control of grid layouts\n */\nexport function useGridKeyboard({\n  enabled = true,\n  blocks,\n  onResizeBlock,\n  onFocusBlock,\n  onCollapseBlock,\n  onExpandBlock,\n  containerRef,\n  stepSize = 10,\n  largeStepSize = 50\n}: UseGridKeyboardOptions) {\n\n  /**\n   * Get the currently focused block element\n   */\n  const getFocusedBlock = useCallback((): HTMLElement | null => {\n    const activeElement = document.activeElement as HTMLElement\n\n    // Check if the active element is a block\n    if (activeElement?.dataset.blockType === 'block' || activeElement?.dataset.blockType === 'group') {\n      return activeElement\n    }\n\n    // Check if active element is within a block\n    const blockElement = activeElement?.closest('[data-block-type=\"block\"], [data-block-type=\"group\"]') as HTMLElement\n    return blockElement || null\n  }, [])\n\n  /**\n   * Get the block configuration for a given element\n   */\n  const getBlockConfig = useCallback((element: HTMLElement | null): BlockConfig | null => {\n    if (!element) return null\n\n    const blockId = element.dataset.blockId\n    return blocks.find(block => block.id === blockId) || null\n  }, [blocks])\n\n  /**\n   * Find the next focusable block in a given direction\n   */\n  const findNextBlock = useCallback((\n    currentBlock: HTMLElement,\n    direction: 'up' | 'down' | 'left' | 'right'\n  ): HTMLElement | null => {\n    if (!containerRef?.current) return null\n\n    const allBlocks = Array.from(\n      containerRef.current.querySelectorAll('[data-block-type=\"block\"], [data-block-type=\"group\"]')\n    ) as HTMLElement[]\n\n    const currentRect = currentBlock.getBoundingClientRect()\n    const currentCenter = {\n      x: currentRect.left + currentRect.width / 2,\n      y: currentRect.top + currentRect.height / 2\n    }\n\n    // Filter blocks based on direction\n    const candidates = allBlocks.filter(block => {\n      if (block === currentBlock) return false\n\n      const rect = block.getBoundingClientRect()\n      const center = {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2\n      }\n\n      switch (direction) {\n        case 'up':\n          return center.y < currentCenter.y\n        case 'down':\n          return center.y > currentCenter.y\n        case 'left':\n          return center.x < currentCenter.x\n        case 'right':\n          return center.x > currentCenter.x\n        default:\n          return false\n      }\n    })\n\n    // Find the closest candidate\n    if (candidates.length === 0) return null\n\n    candidates.sort((a, b) => {\n      const aRect = a.getBoundingClientRect()\n      const bRect = b.getBoundingClientRect()\n      const aCenter = {\n        x: aRect.left + aRect.width / 2,\n        y: aRect.top + aRect.height / 2\n      }\n      const bCenter = {\n        x: bRect.left + bRect.width / 2,\n        y: bRect.top + bRect.height / 2\n      }\n\n      // Calculate distance\n      const aDist = Math.sqrt(\n        Math.pow(aCenter.x - currentCenter.x, 2) +\n        Math.pow(aCenter.y - currentCenter.y, 2)\n      )\n      const bDist = Math.sqrt(\n        Math.pow(bCenter.x - currentCenter.x, 2) +\n        Math.pow(bCenter.y - currentCenter.y, 2)\n      )\n\n      return aDist - bDist\n    })\n\n    return candidates[0]\n  }, [containerRef])\n\n  /**\n   * Handle keyboard events\n   */\n  const handleKeyDown = useCallback((event: KeyboardEvent) => {\n    if (!enabled) return\n\n    const focusedBlock = getFocusedBlock()\n    if (!focusedBlock) return\n\n    const blockConfig = getBlockConfig(focusedBlock)\n    if (!blockConfig) return\n\n    const isCtrlOrCmd = event.ctrlKey || event.metaKey\n    const isShift = event.shiftKey\n    const currentStepSize = isShift ? largeStepSize : stepSize\n\n    // Navigation (arrow keys without modifiers)\n    if (!isCtrlOrCmd && !isShift) {\n      switch (event.key) {\n        case 'ArrowUp':\n          event.preventDefault()\n          const upBlock = findNextBlock(focusedBlock, 'up')\n          if (upBlock) {\n            upBlock.focus()\n            onFocusBlock?.(upBlock.dataset.blockId || '')\n          }\n          break\n\n        case 'ArrowDown':\n          event.preventDefault()\n          const downBlock = findNextBlock(focusedBlock, 'down')\n          if (downBlock) {\n            downBlock.focus()\n            onFocusBlock?.(downBlock.dataset.blockId || '')\n          }\n          break\n\n        case 'ArrowLeft':\n          event.preventDefault()\n          const leftBlock = findNextBlock(focusedBlock, 'left')\n          if (leftBlock) {\n            leftBlock.focus()\n            onFocusBlock?.(leftBlock.dataset.blockId || '')\n          }\n          break\n\n        case 'ArrowRight':\n          event.preventDefault()\n          const rightBlock = findNextBlock(focusedBlock, 'right')\n          if (rightBlock) {\n            rightBlock.focus()\n            onFocusBlock?.(rightBlock.dataset.blockId || '')\n          }\n          break\n\n        case 'Enter':\n        case ' ':\n          event.preventDefault()\n          // Toggle collapse/expand\n          if (blockConfig.collapsible) {\n            // Check if currently collapsed (this would need to be provided by parent)\n            // For now, just trigger expand\n            onExpandBlock?.(blockConfig.id)\n          }\n          break\n\n        case 'Escape':\n          event.preventDefault()\n          focusedBlock.blur()\n          break\n      }\n    }\n\n    // Resizing (Ctrl/Cmd + arrow keys)\n    if (isCtrlOrCmd && onResizeBlock) {\n      switch (event.key) {\n        case 'ArrowUp':\n          event.preventDefault()\n          onResizeBlock(blockConfig.id, -currentStepSize)\n          break\n\n        case 'ArrowDown':\n          event.preventDefault()\n          onResizeBlock(blockConfig.id, currentStepSize)\n          break\n\n        case 'ArrowLeft':\n          event.preventDefault()\n          onResizeBlock(blockConfig.id, -currentStepSize)\n          break\n\n        case 'ArrowRight':\n          event.preventDefault()\n          onResizeBlock(blockConfig.id, currentStepSize)\n          break\n      }\n    }\n\n    // Collapse/Expand (Ctrl/Cmd + specific keys)\n    if (isCtrlOrCmd) {\n      switch (event.key) {\n        case 'Minus':\n        case '-':\n          event.preventDefault()\n          onCollapseBlock?.(blockConfig.id)\n          break\n\n        case 'Plus':\n        case '+':\n        case '=':\n          event.preventDefault()\n          onExpandBlock?.(blockConfig.id)\n          break\n      }\n    }\n  }, [\n    enabled,\n    getFocusedBlock,\n    getBlockConfig,\n    findNextBlock,\n    onResizeBlock,\n    onFocusBlock,\n    onCollapseBlock,\n    onExpandBlock,\n    stepSize,\n    largeStepSize\n  ])\n\n  /**\n   * Focus a specific block\n   */\n  const focusBlock = useCallback((blockId: string) => {\n    if (!containerRef?.current) return\n\n    const blockElement = containerRef.current.querySelector(\n      `[data-block-id=\"${blockId}\"]`\n    ) as HTMLElement\n\n    if (blockElement) {\n      blockElement.focus()\n      onFocusBlock?.(blockId)\n    }\n  }, [containerRef, onFocusBlock])\n\n  /**\n   * Get all focusable blocks\n   */\n  const getFocusableBlocks = useCallback((): HTMLElement[] => {\n    if (!containerRef?.current) return []\n\n    return Array.from(\n      containerRef.current.querySelectorAll(\n        '[data-block-type=\"block\"][tabindex], [data-block-type=\"group\"][tabindex]'\n      )\n    ) as HTMLElement[]\n  }, [containerRef])\n\n  // Set up keyboard event listeners\n  useEffect(() => {\n    if (!enabled) return\n\n    document.addEventListener('keydown', handleKeyDown)\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown)\n    }\n  }, [handleKeyDown, enabled])\n\n  return {\n    focusBlock,\n    getFocusableBlocks,\n    getFocusedBlock,\n    isEnabled: enabled\n  }\n}",
      "target": "hooks/use-grid-keyboard.ts"
    },
    {
      "path": "lib/grid-calculations.ts",
      "type": "registry:lib",
      "content": "/**\n * Grid calculation utilities ported from grid_resize.ts\n */\n\n/**\n * Calculate available flex space in pixels\n * @param containerPx Total container size in pixels\n * @param fixedTrackPx Sum of all fixed (px) tracks\n * @param gapsPx Sum of all gap sizes\n * @returns Available space for fr units\n */\nexport function getFlexSpacePx(\n  containerPx: number,\n  fixedTrackPx: number,\n  gapsPx: number\n): number {\n  return Math.max(0, containerPx - fixedTrackPx - gapsPx)\n}\n\n/**\n * Calculate pixels per fr unit\n * @param flexSpacePx Available flex space in pixels\n * @param totalFr Total fr units in the container\n * @returns Pixels per fr unit\n */\nexport function pxPerFr(flexSpacePx: number, totalFr: number): number {\n  return totalFr > 0 ? flexSpacePx / totalFr : 0\n}\n\n/**\n * Clamp a value between min and max bounds\n * @param value Value to clamp\n * @param min Minimum value\n * @param max Maximum value\n * @returns Clamped value\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max)\n}\n\n/**\n * Check if a value is collapsed based on threshold\n * @param value Current value\n * @param collapseAt Threshold for collapsing\n * @returns True if value should be considered collapsed\n */\nexport function isCollapsed(value: number, collapseAt: number): boolean {\n  return collapseAt > 0 && value <= collapseAt\n}\n\n/**\n * Apply collapse logic to a resize operation\n * @param newSize Proposed new size\n * @param currentSize Current size\n * @param collapseAt Collapse threshold\n * @param collapseTo Size to collapse to\n * @param defaultSize Default size to expand to\n * @returns Adjusted size with collapse logic applied\n */\nexport function applyCollapseLogic(\n  newSize: number,\n  currentSize: number,\n  collapseAt: number,\n  collapseTo: number,\n  defaultSize: number\n): number {\n  // Skip if collapsing is disabled\n  if (collapseAt === 0) {\n    return newSize\n  }\n\n  const isCurrentlyCollapsed = currentSize <= collapseAt\n\n  // If currently collapsed and trying to expand significantly, snap to default\n  // Use a threshold: expand if newSize is more than double collapseTo\n  const expandThreshold = collapseTo * 2.5\n  if (isCurrentlyCollapsed && newSize > expandThreshold) {\n    return defaultSize\n  }\n\n  // If new size would be below threshold, collapse it\n  // But if we're already collapsed, don't force further collapse\n  if (newSize < collapseAt && !isCurrentlyCollapsed) {\n    return collapseTo\n  }\n\n  return newSize\n}\n\n/**\n * Calculate new size with constraints applied\n * @param deltaPx Change in pixels\n * @param initialSize Initial size value\n * @param minSize Minimum allowed size\n * @param maxSize Maximum allowed size\n * @param invertDelta Whether to invert the delta (for start dividers)\n * @returns New size with constraints applied\n */\nexport function calculateConstrainedSize(\n  deltaPx: number,\n  initialSize: number,\n  minSize: number = 0,\n  maxSize: number = Infinity,\n  invertDelta: boolean = false\n): number {\n  const adjustedDelta = invertDelta ? -deltaPx : deltaPx\n  const rawNewSize = initialSize + adjustedDelta\n\n  return clamp(rawNewSize, minSize, maxSize)\n}\n\n/**\n * Generate CSS grid template value without dividers (dividers are now overlays)\n * @param blocks Block configurations\n * @param gridId Grid ID for scoping CSS variables\n * @returns CSS grid-template string\n */\nexport function generateGridTemplate(\n  blocks: Array<{\n    id: string\n    sizeUnit: \"px\" | \"fr\" | \"auto\"\n    size: number | \"auto\"\n    dividerPosition?: \"start\" | \"end\" | \"none\"\n    dividerSize?: number\n  }>,\n  gridId?: string\n): string {\n  const parts: string[] = []\n\n  blocks.forEach(block => {\n    // Add the block itself (no dividers - they're overlays now)\n    if (block.sizeUnit === \"auto\") {\n      parts.push(\"auto\")\n    } else if (block.sizeUnit === \"px\") {\n      const varName = gridId ? `--${gridId}-${block.id}-size` : `--${block.id}-size`\n      parts.push(`var(${varName}, ${block.size}px)`)\n    } else {\n      const varName = gridId ? `--${gridId}-${block.id}-size` : `--${block.id}-size`\n      parts.push(`var(${varName}, ${block.size}fr)`)\n    }\n  })\n\n  return parts.join(\" \")\n}\n\n/**\n * Generate CSS grid template from template items (for auto divider mode)\n * Note: Dividers are now overlays, so they're excluded from grid template\n * @param items Template items including blocks and dividers\n * @param gridId Grid ID for scoping CSS variables\n * @returns CSS grid-template string\n */\nexport function generateGridTemplateFromItems(\n  items: Array<{\n    id: string\n    type: 'block' | 'divider'\n    sizeUnit?: 'px' | 'fr' | 'auto'\n    size?: number\n    dividerSize?: number\n  }>,\n  gridId?: string\n): string {\n  const parts: string[] = []\n\n  items.forEach(item => {\n    // Skip dividers - they're overlays now\n    if (item.type === 'divider') {\n      return\n    }\n\n    // Block with CSS variable support\n    if (item.sizeUnit === 'auto') {\n      parts.push('auto')\n    } else if (item.sizeUnit === 'px') {\n      const varName = gridId ? `--${gridId}-${item.id}-size` : `--${item.id}-size`\n      parts.push(`var(${varName}, ${item.size || 1}px)`)\n    } else {\n      const varName = gridId ? `--${gridId}-${item.id}-size` : `--${item.id}-size`\n      parts.push(`var(${varName}, ${item.size || 1}fr)`)\n    }\n  })\n\n  return parts.join(' ')\n}\n\n/**\n * Convert fractional resize delta to pixels\n * @param deltaFr Change in fr units\n * @param pixelsPerFr Pixels per fr unit\n * @returns Delta in pixels\n */\nexport function frToPx(deltaFr: number, pixelsPerFr: number): number {\n  return deltaFr * pixelsPerFr\n}\n\n/**\n * Convert pixel delta to fractional units\n * @param deltaPx Change in pixels\n * @param pixelsPerFr Pixels per fr unit\n * @returns Delta in fr units\n */\nexport function pxToFr(deltaPx: number, pixelsPerFr: number): number {\n  return pixelsPerFr > 0 ? deltaPx / pixelsPerFr : 0\n}\n\n/**\n * Find adjacent block for two-way resizing\n * @param targetIndex Index of target block\n * @param blocks Array of blocks\n * @param position Divider position (\"start\" or \"end\")\n * @returns Adjacent block or null\n */\nexport function findAdjacentBlock<T>(\n  targetIndex: number,\n  blocks: T[],\n  position: \"start\" | \"end\"\n): T | null {\n  if (position === \"start\") {\n    return targetIndex > 0 ? blocks[targetIndex - 1] : null\n  } else {\n    return targetIndex < blocks.length - 1 ? blocks[targetIndex + 1] : null\n  }\n}\n\n/**\n * Validate that two deltas maintain zero-sum constraint\n * @param targetDelta Change in target size\n * @param adjacentDelta Change in adjacent size\n * @param tolerance Acceptable deviation from zero sum\n * @returns True if zero-sum is maintained within tolerance\n */\nexport function isZeroSum(\n  targetDelta: number,\n  adjacentDelta: number,\n  tolerance: number = 0.001\n): boolean {\n  return Math.abs(targetDelta + adjacentDelta) <= tolerance\n}",
      "target": "lib/grid-calculations.ts"
    },
    {
      "path": "lib/grid-constraints.ts",
      "type": "registry:lib",
      "content": "import type { BlockConfig, SizeUnit } from \"@/lib/grid-types\"\nimport { clamp, applyCollapseLogic } from \"@/lib/grid-calculations\"\n\n/**\n * Constraint validation and enforcement utilities\n */\n\nexport interface ConstraintResult {\n  isValid: boolean\n  adjustedValue: number\n  violations: string[]\n}\n\n/**\n * Validate and adjust a block size against its constraints\n * @param newSize Proposed new size\n * @param block Block configuration with constraints\n * @param currentSize Current size (for collapse logic)\n * @returns Constraint validation result\n */\nexport function validateBlockSize(\n  newSize: number,\n  block: BlockConfig,\n  currentSize?: number\n): ConstraintResult {\n  const violations: string[] = []\n  let adjustedValue = newSize\n\n  // Basic range constraints\n  const minSize = block.minSize ?? 0\n  const maxSize = block.maxSize ?? Infinity\n\n  if (newSize < minSize) {\n    violations.push(`Size ${newSize} is below minimum ${minSize}`)\n    adjustedValue = minSize\n  }\n\n  if (newSize > maxSize) {\n    violations.push(`Size ${newSize} exceeds maximum ${maxSize}`)\n    adjustedValue = maxSize\n  }\n\n  // Apply min/max clamping\n  adjustedValue = clamp(adjustedValue, minSize, maxSize)\n\n  // Apply collapse logic for px units\n  if (block.sizeUnit === 'px' && block.collapsible && currentSize !== undefined) {\n    const collapseAt = block.collapseAt ?? 0\n    const collapseTo = block.collapseTo ?? 0\n    const defaultSize = block.defaultSize ?? adjustedValue\n\n    adjustedValue = applyCollapseLogic(\n      adjustedValue,\n      currentSize,\n      collapseAt,\n      collapseTo,\n      defaultSize\n    )\n  }\n\n  return {\n    isValid: violations.length === 0,\n    adjustedValue,\n    violations\n  }\n}\n\n/**\n * Validate two-way resize constraints (zero-sum)\n * @param targetBlock Target block configuration\n * @param adjacentBlock Adjacent block configuration\n * @param targetDelta Proposed change to target\n * @param adjacentDelta Proposed change to adjacent\n * @param pixelsPerFr Pixels per fr unit (for fr calculations)\n * @returns Validation result with adjusted deltas\n */\nexport function validateTwoWayResize(\n  targetBlock: BlockConfig,\n  adjacentBlock: BlockConfig,\n  targetDelta: number,\n  adjacentDelta: number,\n  pixelsPerFr: number = 1\n): {\n  isValid: boolean\n  adjustedTargetDelta: number\n  adjustedAdjacentDelta: number\n  violations: string[]\n} {\n  const violations: string[] = []\n  let adjustedTargetDelta = targetDelta\n  let adjustedAdjacentDelta = adjacentDelta\n\n  // Convert constraints to common unit (pixels)\n  const targetMin = getConstraintInPx(targetBlock.minSize ?? 0, targetBlock.sizeUnit, pixelsPerFr)\n  const targetMax = getConstraintInPx(targetBlock.maxSize ?? Infinity, targetBlock.sizeUnit, pixelsPerFr)\n  const adjacentMin = getConstraintInPx(adjacentBlock.minSize ?? 0, adjacentBlock.sizeUnit, pixelsPerFr)\n  const adjacentMax = getConstraintInPx(adjacentBlock.maxSize ?? Infinity, adjacentBlock.sizeUnit, pixelsPerFr)\n\n  const currentTargetSize = getConstraintInPx(targetBlock.defaultSize ?? 0, targetBlock.sizeUnit, pixelsPerFr)\n  const currentAdjacentSize = getConstraintInPx(adjacentBlock.defaultSize ?? 0, adjacentBlock.sizeUnit, pixelsPerFr)\n\n  // Calculate proposed new sizes\n  const newTargetSize = currentTargetSize + targetDelta\n  const newAdjacentSize = currentAdjacentSize + adjacentDelta\n\n  // Check individual constraints\n  let constrainedTargetSize = clamp(newTargetSize, targetMin, targetMax)\n  let constrainedAdjacentSize = clamp(newAdjacentSize, adjacentMin, adjacentMax)\n\n  // Adjust deltas based on constraints\n  adjustedTargetDelta = constrainedTargetSize - currentTargetSize\n  adjustedAdjacentDelta = constrainedAdjacentSize - currentAdjacentSize\n\n  // Ensure zero-sum by adjusting the less constrained block\n  const deltaSum = adjustedTargetDelta + adjustedAdjacentDelta\n\n  if (Math.abs(deltaSum) > 0.001) {\n    // One block hit a constraint, adjust the other to maintain zero-sum\n    const targetHitConstraint = Math.abs(adjustedTargetDelta) < Math.abs(targetDelta)\n    const adjacentHitConstraint = Math.abs(adjustedAdjacentDelta) < Math.abs(adjacentDelta)\n\n    if (targetHitConstraint && !adjacentHitConstraint) {\n      // Target hit constraint, adjust adjacent to compensate\n      const compensatedAdjacentSize = currentAdjacentSize - adjustedTargetDelta\n      constrainedAdjacentSize = clamp(compensatedAdjacentSize, adjacentMin, adjacentMax)\n      adjustedAdjacentDelta = constrainedAdjacentSize - currentAdjacentSize\n    } else if (adjacentHitConstraint && !targetHitConstraint) {\n      // Adjacent hit constraint, adjust target to compensate\n      const compensatedTargetSize = currentTargetSize - adjustedAdjacentDelta\n      constrainedTargetSize = clamp(compensatedTargetSize, targetMin, targetMax)\n      adjustedTargetDelta = constrainedTargetSize - currentTargetSize\n    }\n\n    violations.push('Zero-sum constraint violated, deltas adjusted')\n  }\n\n  // Final zero-sum check\n  const finalSum = adjustedTargetDelta + adjustedAdjacentDelta\n  const isValid = Math.abs(finalSum) <= 0.001\n\n  return {\n    isValid,\n    adjustedTargetDelta,\n    adjustedAdjacentDelta,\n    violations\n  }\n}\n\n/**\n * Convert a constraint value to pixels\n * @param value Constraint value\n * @param unit Size unit\n * @param pixelsPerFr Conversion rate for fr units\n * @returns Value in pixels\n */\nfunction getConstraintInPx(\n  value: number | undefined,\n  unit: SizeUnit | undefined,\n  pixelsPerFr: number\n): number {\n  if (value === undefined || value === Infinity) {\n    return Infinity\n  }\n\n  switch (unit) {\n    case 'px':\n      return value\n    case 'fr':\n      return value * pixelsPerFr\n    case 'auto':\n    default:\n      return value\n  }\n}\n\n/**\n * Check if a resize operation would create invalid layout\n * @param blocks All blocks in the container\n * @param changes Proposed size changes\n * @returns Validation result\n */\nexport function validateLayoutIntegrity(\n  blocks: BlockConfig[],\n  changes: Record<string, number>\n): {\n  isValid: boolean\n  violations: string[]\n} {\n  const violations: string[] = []\n\n  // Check for overlapping constraints\n  const totalFixedSize = blocks\n    .filter(block => block.sizeUnit === 'px')\n    .reduce((sum, block) => sum + (changes[block.id] ?? block.defaultSize ?? 0), 0)\n\n  const totalFrUnits = blocks\n    .filter(block => block.sizeUnit === 'fr')\n    .reduce((sum, block) => sum + (changes[block.id] ?? block.defaultSize ?? 0), 0)\n\n  // Basic sanity checks\n  if (totalFixedSize < 0) {\n    violations.push('Total fixed size cannot be negative')\n  }\n\n  if (totalFrUnits <= 0 && blocks.some(block => block.sizeUnit === 'fr')) {\n    violations.push('Total fr units must be positive')\n  }\n\n  // Check for constraint conflicts\n  blocks.forEach(block => {\n    const newSize = changes[block.id] ?? block.defaultSize ?? 0\n    const minSize = block.minSize ?? 0\n    const maxSize = block.maxSize ?? Infinity\n\n    if (minSize > maxSize) {\n      violations.push(`Block ${block.id}: minSize (${minSize}) > maxSize (${maxSize})`)\n    }\n\n    if (newSize < minSize || newSize > maxSize) {\n      violations.push(`Block ${block.id}: size ${newSize} violates constraints [${minSize}, ${maxSize}]`)\n    }\n  })\n\n  return {\n    isValid: violations.length === 0,\n    violations\n  }\n}",
      "target": "lib/grid-constraints.ts"
    },
    {
      "path": "lib/grid-storage.ts",
      "type": "registry:lib",
      "content": "import type { GridState } from \"@/lib/grid-types\"\n\n/**\n * Storage utilities for grid state persistence\n */\n\nconst STORAGE_KEY_PREFIX = 'pretty-poly-grid-'\n\nexport interface StorageAdapter {\n  save: (key: string, data: unknown) => void\n  load: (key: string) => unknown | null\n  remove: (key: string) => void\n  clear: () => void\n}\n\n/**\n * localStorage adapter\n */\nexport const localStorageAdapter: StorageAdapter = {\n  save: (key: string, data: unknown) => {\n    try {\n      localStorage.setItem(key, JSON.stringify(data))\n    } catch (error) {\n      console.warn('Failed to save to localStorage:', error)\n    }\n  },\n\n  load: (key: string) => {\n    try {\n      const stored = localStorage.getItem(key)\n      return stored ? JSON.parse(stored) : null\n    } catch (error) {\n      console.warn('Failed to load from localStorage:', error)\n      return null\n    }\n  },\n\n  remove: (key: string) => {\n    try {\n      localStorage.removeItem(key)\n    } catch (error) {\n      console.warn('Failed to remove from localStorage:', error)\n    }\n  },\n\n  clear: () => {\n    try {\n      // Remove only our keys\n      const keysToRemove = []\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i)\n        if (key && key.startsWith(STORAGE_KEY_PREFIX)) {\n          keysToRemove.push(key)\n        }\n      }\n      keysToRemove.forEach(key => localStorage.removeItem(key))\n    } catch (error) {\n      console.warn('Failed to clear localStorage:', error)\n    }\n  }\n}\n\n/**\n * sessionStorage adapter\n */\nexport const sessionStorageAdapter: StorageAdapter = {\n  save: (key: string, data: unknown) => {\n    try {\n      sessionStorage.setItem(key, JSON.stringify(data))\n    } catch (error) {\n      console.warn('Failed to save to sessionStorage:', error)\n    }\n  },\n\n  load: (key: string) => {\n    try {\n      const stored = sessionStorage.getItem(key)\n      return stored ? JSON.parse(stored) : null\n    } catch (error) {\n      console.warn('Failed to load from sessionStorage:', error)\n      return null\n    }\n  },\n\n  remove: (key: string) => {\n    try {\n      sessionStorage.removeItem(key)\n    } catch (error) {\n      console.warn('Failed to remove from sessionStorage:', error)\n    }\n  },\n\n  clear: () => {\n    try {\n      // Remove only our keys\n      const keysToRemove = []\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i)\n        if (key && key.startsWith(STORAGE_KEY_PREFIX)) {\n          keysToRemove.push(key)\n        }\n      }\n      keysToRemove.forEach(key => sessionStorage.removeItem(key))\n    } catch (error) {\n      console.warn('Failed to clear sessionStorage:', error)\n    }\n  }\n}\n\n/**\n * Memory adapter (for testing or when storage is not available)\n */\nconst memoryStorage = new Map<string, unknown>()\n\nexport const memoryStorageAdapter: StorageAdapter = {\n  save: (key: string, data: unknown) => {\n    memoryStorage.set(key, data)\n  },\n\n  load: (key: string) => {\n    return memoryStorage.get(key) || null\n  },\n\n  remove: (key: string) => {\n    memoryStorage.delete(key)\n  },\n\n  clear: () => {\n    // Remove only our keys\n    for (const key of memoryStorage.keys()) {\n      if (key.startsWith(STORAGE_KEY_PREFIX)) {\n        memoryStorage.delete(key)\n      }\n    }\n  }\n}\n\n/**\n * Get appropriate storage adapter\n * @param type Storage type preference\n * @returns Storage adapter\n */\nexport function getStorageAdapter(type: 'localStorage' | 'sessionStorage' | 'memory'): StorageAdapter {\n  switch (type) {\n    case 'localStorage':\n      return typeof localStorage !== 'undefined' ? localStorageAdapter : memoryStorageAdapter\n    case 'sessionStorage':\n      return typeof sessionStorage !== 'undefined' ? sessionStorageAdapter : memoryStorageAdapter\n    case 'memory':\n    default:\n      return memoryStorageAdapter\n  }\n}\n\n/**\n * Generate storage key\n * @param gridId Grid identifier\n * @returns Full storage key\n */\nexport function getStorageKey(gridId: string): string {\n  return `${STORAGE_KEY_PREFIX}${gridId}`\n}\n\n/**\n * Save grid state\n * @param gridId Grid identifier\n * @param state Grid state to save\n * @param adapter Storage adapter to use\n */\nexport function saveGridState(\n  gridId: string,\n  state: GridState,\n  adapter: StorageAdapter = localStorageAdapter\n): void {\n  const key = getStorageKey(gridId)\n\n  // Only save the parts we need to persist\n  const persistableState = {\n    blocks: state.blocks,\n    activeMode: state.activeMode,\n    // Don't persist viewport or transient state like activeDivider\n  }\n\n  adapter.save(key, persistableState)\n}\n\n/**\n * Load grid state\n * @param gridId Grid identifier\n * @param adapter Storage adapter to use\n * @returns Loaded grid state or null\n */\nexport function loadGridState(\n  gridId: string,\n  adapter: StorageAdapter = localStorageAdapter\n): Partial<GridState> | null {\n  const key = getStorageKey(gridId)\n  return adapter.load(key) as Partial<GridState> | null\n}\n\n/**\n * Remove grid state\n * @param gridId Grid identifier\n * @param adapter Storage adapter to use\n */\nexport function removeGridState(\n  gridId: string,\n  adapter: StorageAdapter = localStorageAdapter\n): void {\n  const key = getStorageKey(gridId)\n  adapter.remove(key)\n}\n\n/**\n * Get all saved grid states\n * @param adapter Storage adapter to use\n * @returns Map of grid ID to state\n */\nexport function getAllGridStates(\n  adapter: StorageAdapter = localStorageAdapter\n): Record<string, Partial<GridState>> {\n  const states: Record<string, Partial<GridState>> = {}\n\n  try {\n    // This is a bit hacky but works for localStorage/sessionStorage\n    if (adapter === localStorageAdapter && typeof localStorage !== 'undefined') {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i)\n        if (key && key.startsWith(STORAGE_KEY_PREFIX)) {\n          const gridId = key.substring(STORAGE_KEY_PREFIX.length)\n          const state = adapter.load(key)\n          if (state) {\n            states[gridId] = state\n          }\n        }\n      }\n    } else if (adapter === sessionStorageAdapter && typeof sessionStorage !== 'undefined') {\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i)\n        if (key && key.startsWith(STORAGE_KEY_PREFIX)) {\n          const gridId = key.substring(STORAGE_KEY_PREFIX.length)\n          const state = adapter.load(key)\n          if (state) {\n            states[gridId] = state\n          }\n        }\n      }\n    } else if (adapter === memoryStorageAdapter) {\n      for (const key of memoryStorage.keys()) {\n        if (key.startsWith(STORAGE_KEY_PREFIX)) {\n          const gridId = key.substring(STORAGE_KEY_PREFIX.length)\n          const state = adapter.load(key)\n          if (state) {\n            states[gridId] = state\n          }\n        }\n      }\n    }\n  } catch (error) {\n    console.warn('Failed to get all grid states:', error)\n  }\n\n  return states\n}\n\n/**\n * Create a custom storage adapter from a function\n * @param saveState Function to save state\n * @returns Custom storage adapter\n */\nexport function createCustomAdapter(saveState: (state: GridState) => void): StorageAdapter {\n  return {\n    save: (_key: string, data: unknown) => saveState(data as GridState),\n    load: () => null, // Custom adapters typically don't load\n    remove: () => {},\n    clear: () => {}\n  }\n}",
      "target": "lib/grid-storage.ts"
    },
    {
      "path": "lib/grid-types.ts",
      "type": "registry:lib",
      "content": "// Core grid types\nexport type BlockType = \"block\" | \"group\"\nexport type SizeUnit = \"px\" | \"fr\" | \"auto\"\nexport type Direction = \"row\" | \"column\"\nexport type DividerPosition = \"start\" | \"end\" | \"none\" | \"auto\"\n\n// Layout modes for responsive behavior (grid-level)\nexport type LayoutMode =\n  | \"grid\"      // Desktop: resizable grid with dividers\n  | \"dock\"      // Mobile: bottom navigation with icon switching\n  | \"tabs\"      // Tablet: tab interface\n\n// Note: stack, sidebar, and accordion are block-level sub-layouts,\n// not grid-level layout modes\n\n// Block configuration\nexport interface BlockConfig {\n  id: string\n  type: BlockType\n  direction?: Direction\n\n  // Size configuration\n  defaultSize?: number\n  minSize?: number\n  maxSize?: number\n  sizeUnit?: SizeUnit\n\n  // Runtime size tracking\n  size?: number\n  originalDefaultSize?: number\n\n  // Collapse behavior\n  collapsible?: boolean\n  collapseAt?: number\n  collapseTo?: number\n\n  // Divider configuration\n  dividerPosition?: DividerPosition\n  dividerSize?: number\n\n  // Hierarchy\n  parentId?: string\n  order?: number\n  children?: string[]\n}\n\n// Mode-specific block configuration\nexport interface ModeConfig {\n  // Grid mode (desktop)\n  defaultSize?: number\n  minSize?: number\n  maxSize?: number\n  sizingMode?: \"fixed\" | \"fill\" | \"auto\"\n  collapsible?: boolean\n\n  // Dock mode (mobile)\n  icon?: React.ComponentType<{ className?: string }>\n  label?: string\n  dockOrder?: number\n\n  // Tab mode (tablet)\n  tabLabel?: string\n  closable?: boolean\n\n  // Common\n  hidden?: boolean\n  className?: string\n  style?: React.CSSProperties\n}\n\n// Responsive mode configuration\nexport interface ResponsiveModes {\n  [modeName: string]: {\n    type: LayoutMode\n    breakpoint?: number\n    minWidth?: number\n    maxWidth?: number\n    matcher?: (viewport: ViewportInfo) => boolean\n  }\n}\n\n// Viewport information\nexport interface ViewportInfo {\n  width: number\n  height: number\n  orientation: \"portrait\" | \"landscape\"\n}\n\n// Resize state\nexport interface ResizeState {\n  isDragging: boolean\n  activeBlockId?: string\n  activeDividerId?: string\n  startPosition: { x: number; y: number }\n  initialSize: number\n  initialAdjacentBlockId?: string\n  initialAdjacentSize?: number\n}\n\n// Grid state\nexport interface GridState {\n  blocks: Record<string, BlockConfig>\n  activeMode: string\n  activeDivider?: string\n  viewport: ViewportInfo\n  resize: ResizeState\n}\n\n// Grid context\nexport interface GridContextValue {\n  gridId: string\n  state: GridState\n  dispatch: React.Dispatch<GridAction>\n\n  // Grid operations\n  resizeBlock: (blockId: string, size: number) => void\n  collapseBlock: (blockId: string) => void\n  expandBlock: (blockId: string) => void\n  switchMode: (mode: string) => void\n\n  // Resize operations\n  startResize: (blockId: string, dividerId: string, event: React.MouseEvent | React.TouchEvent) => void\n  updateResize: (event: MouseEvent | TouchEvent) => void\n  endResize: () => void\n\n  // Persistence\n  persistState: () => void\n  resetState: () => void\n}\n\n// Grid actions\nexport type GridAction =\n  | { type: \"RESIZE_BLOCK\"; payload: { blockId: string; size: number } }\n  | { type: \"COLLAPSE_BLOCK\"; payload: { blockId: string } }\n  | { type: \"EXPAND_BLOCK\"; payload: { blockId: string } }\n  | { type: \"SET_ACTIVE_DIVIDER\"; payload: { dividerId?: string } }\n  | { type: \"SWITCH_MODE\"; payload: { mode: string } }\n  | { type: \"UPDATE_VIEWPORT\"; payload: { viewport: ViewportInfo } }\n  | { type: \"LOAD_STATE\"; payload: { state: Partial<GridState> } }\n  | { type: \"RESET_STATE\" }\n  | { type: \"START_RESIZE\"; payload: { blockId: string; dividerId: string; startPosition: { x: number; y: number }; initialSize: number; initialAdjacentBlockId?: string; initialAdjacentSize?: number } }\n  | { type: \"UPDATE_RESIZE\"; payload: { currentPosition: { x: number; y: number } } }\n  | { type: \"END_RESIZE\" }\n\n// Component props\nexport interface GridProps {\n  children: React.ReactNode\n  className?: string\n\n  // Layout configuration\n  defaultLayout?: BlockConfig[]\n  modes?: ResponsiveModes\n\n  // Divider configuration (new automatic system)\n  dividers?: \"auto\" | \"manual\" | \"none\"\n  dividerConfig?: GridDividerConfig\n\n  // Persistence\n  persist?: boolean | \"localStorage\" | \"sessionStorage\" | ((state: GridState) => void)\n  persistKey?: string\n\n  // Event handlers\n  onLayoutChange?: (layout: BlockConfig[]) => void\n  onModeChange?: (mode: string, previousMode: string) => void\n\n  // Accessibility\n  \"aria-label\"?: string\n}\n\nexport interface BlockProps {\n  id: string\n  type?: BlockType\n  direction?: Direction\n  children?: React.ReactNode\n  className?: string\n\n  // Divider configuration (new automatic system)\n  divider?: boolean | DividerConfig\n  noDivider?: boolean\n\n  // Mode-specific configurations\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [modeName: string]: any\n\n  // Accessibility\n  \"aria-label\"?: string\n}\n\n// Divider configuration for blocks\nexport interface DividerConfig {\n  position?: DividerPosition\n  size?: number\n  className?: string\n  handle?: React.ComponentType<{ className?: string; direction: Direction }>\n  onDoubleClick?: () => void\n  \"aria-label\"?: string\n}\n\n// Grid-level divider configuration\nexport interface GridDividerConfig {\n  defaultSize?: number\n  defaultClassName?: string\n  defaultHandle?: React.ComponentType<{ className?: string; direction: Direction }>\n  overrides?: Record<string, Partial<DividerConfig>>\n}\n\nexport interface DividerProps {\n  targetId?: string // Optional - defaults to previous sibling block\n  position?: DividerPosition // Optional - defaults to auto-detection\n  size?: number\n  className?: string\n\n  // Customization\n  handle?: React.ComponentType<{ className?: string }>\n\n  // Accessibility\n  \"aria-label\"?: string\n}\n\n// Utility types\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]\n}\n\nexport type BlockTree = {\n  config: BlockConfig\n  children: BlockTree[]\n}\n\n// Block content system types\nexport type ScrollMode = 'vertical' | 'horizontal' | 'both' | 'none'\nexport type HeaderPosition = 'top' | 'bottom'\n\n// Block content component props\nexport interface BlockContentProps {\n  scrollMode?: ScrollMode\n  className?: string\n  children: React.ReactNode\n  'aria-label'?: string\n}\n\nexport interface BlockHeaderProps {\n  position?: HeaderPosition\n  className?: string\n  children: React.ReactNode\n  'aria-label'?: string\n}\n\nexport interface BlockFooterProps {\n  className?: string\n  children: React.ReactNode\n  'aria-label'?: string\n}\n\nexport interface BlockToolbarProps {\n  left?: React.ReactNode\n  center?: React.ReactNode\n  right?: React.ReactNode\n  className?: string\n  'aria-label'?: string\n}\n\nexport interface Tab {\n  id: string\n  label: string\n  icon?: React.ComponentType<{ className?: string }>\n  closable?: boolean\n  disabled?: boolean\n}\n\nexport interface BlockTabsProps {\n  tabs: Tab[]\n  activeTab: string\n  onTabChange: (id: string) => void\n  onTabClose?: (id: string) => void\n  className?: string\n  'aria-label'?: string\n  allowOverflow?: boolean\n}\n\n// Block sidebar system types\nexport type SidebarPosition = 'left' | 'right'\n\nexport interface BlockSidebarProps {\n  position?: SidebarPosition\n  width?: number\n  className?: string\n  children: React.ReactNode\n  'aria-label'?: string\n}\n\nexport interface BlockSidebarItemProps {\n  icon: React.ComponentType<{ className?: string }>\n  tooltip?: string\n  active?: boolean\n  disabled?: boolean\n  badge?: number | string\n  onClick?: () => void\n  className?: string\n  'aria-label'?: string\n}\n\nexport interface BlockSidebarSpacerProps {\n  className?: string\n}",
      "target": "lib/grid-types.ts"
    },
    {
      "path": "lib/grid-divider-auto-detection.ts",
      "type": "registry:lib",
      "content": "import type { BlockConfig, DividerPosition, SizeUnit, DividerConfig, Direction } from \"@/lib/grid-types\"\n\n/**\n * Smart auto-detection for divider position based on block size units\n */\nexport function autoDetectDividerPosition(\n  currentBlock: BlockConfig,\n  nextBlock: BlockConfig | null\n): { targetId: string; position: 'start' | 'end' } {\n  if (!nextBlock) {\n    // No next block, divider targets current block from end\n    return { targetId: currentBlock.id, position: 'end' }\n  }\n\n  const currentUnit = currentBlock.sizeUnit || 'fr'\n  const nextUnit = nextBlock.sizeUnit || 'fr'\n\n  // Smart detection rules based on CSS Grid constraints\n  if (currentUnit === 'fr' && nextUnit === 'px') {\n    // fr + px: MUST target px block (fr auto-adjusts to available space)\n    // Divider is BEFORE the px block, so use position 'start'\n    return { targetId: nextBlock.id, position: 'start' }\n  }\n\n  if (currentUnit === 'px' && nextUnit === 'fr') {\n    // px + fr: MUST target px block (fr auto-adjusts to available space)\n    // Divider is AFTER the px block, so use position 'end'\n    // With 'end', drag right (positive delta) grows the block naturally\n    return { targetId: currentBlock.id, position: 'end' }\n  }\n\n  // For same units (fr+fr, px+px, auto+auto), either can resize\n  // Default to first block for consistency\n  return { targetId: currentBlock.id, position: 'end' }\n}\n\n/**\n * Check if a block should have a divider based on its configuration and siblings\n */\nexport function shouldGenerateDivider(\n  _block: BlockConfig,\n  isLastInGroup: boolean,\n  gridDividersMode: 'auto' | 'manual' | 'none',\n  blockDividerProp?: boolean | object,\n  blockNoDivider?: boolean\n): boolean {\n  // Explicit opt-out always wins\n  if (blockNoDivider) {\n    return false\n  }\n\n  // Grid-level dividers disabled\n  if (gridDividersMode === 'none') {\n    return false\n  }\n\n  // Manual mode - only generate if block explicitly requests it\n  if (gridDividersMode === 'manual') {\n    return !!blockDividerProp\n  }\n\n  // Auto mode - generate unless it's the last block or explicitly disabled\n  if (gridDividersMode === 'auto') {\n    // Last block in group never gets a divider\n    if (isLastInGroup) {\n      return false\n    }\n\n    // Generate divider by default, unless explicitly disabled\n    return !blockNoDivider\n  }\n\n  return false\n}\n\n/**\n * Generate divider configuration for a block\n */\nexport function generateDividerConfig(\n  block: BlockConfig,\n  nextBlock: BlockConfig | null,\n  blockDividerProp?: boolean | object,\n  gridDividerConfig?: {\n    defaultSize?: number\n    defaultClassName?: string\n    defaultHandle?: React.ComponentType<{ className?: string; direction: Direction }>\n    overrides?: Record<string, unknown>\n  }\n): {\n  targetId: string\n  position: DividerPosition\n  size: number\n  className?: string\n  handle?: React.ComponentType<{ className?: string; direction: Direction }>\n  onDoubleClick?: () => void\n  'aria-label'?: string\n} {\n  // Detect smart position\n  const { targetId, position } = autoDetectDividerPosition(block, nextBlock)\n\n  // Start with grid defaults\n  const config = {\n    targetId,\n    position,\n    size: gridDividerConfig?.defaultSize || 8,\n    className: gridDividerConfig?.defaultClassName,\n    handle: gridDividerConfig?.defaultHandle,\n  }\n\n  // Apply grid overrides for this specific block\n  const override = gridDividerConfig?.overrides?.[block.id]\n  if (override) {\n    Object.assign(config, override)\n  }\n\n  // Apply block-level configuration\n  if (typeof blockDividerProp === 'object' && blockDividerProp !== null) {\n    const dividerConfig = blockDividerProp as Partial<DividerConfig>\n    Object.assign(config, dividerConfig)\n\n    // If position is explicitly set, update targetId if needed\n    if (dividerConfig.position && dividerConfig.position !== 'auto') {\n      if (dividerConfig.position === 'start') {\n        config.targetId = block.id\n        config.position = 'start'\n      } else if (dividerConfig.position === 'end') {\n        config.targetId = block.id\n        config.position = 'end'\n      }\n    }\n  }\n\n  return config\n}\n\n/**\n * Check if two size units are compatible for resizing\n */\nexport function areUnitsCompatible(unit1: SizeUnit, unit2: SizeUnit): boolean {\n  // px and fr can always resize against each other\n  if ((unit1 === 'px' && unit2 === 'fr') || (unit1 === 'fr' && unit2 === 'px')) {\n    return true\n  }\n\n  // Same units can resize against each other\n  if (unit1 === unit2) {\n    return true\n  }\n\n  // auto is less predictable, but generally compatible\n  if (unit1 === 'auto' || unit2 === 'auto') {\n    return true\n  }\n\n  return false\n}",
      "target": "lib/grid-divider-auto-detection.ts"
    }
  ],
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "tailwind": {
    "config": {
      "theme": {
        "extend": {
          "animation": {
            "grid-divider-fade": "grid-divider-fade 200ms ease-out",
            "grid-divider-slide": "grid-divider-slide 150ms cubic-bezier(0.4, 0, 0.2, 1)"
          },
          "keyframes": {
            "grid-divider-fade": {
              "0%": {
                "opacity": "0"
              },
              "100%": {
                "opacity": "1"
              }
            },
            "grid-divider-slide": {
              "0%": {
                "transform": "translateY(-4px)",
                "opacity": "0"
              },
              "100%": {
                "transform": "translateY(0)",
                "opacity": "1"
              }
            }
          }
        }
      }
    }
  }
}